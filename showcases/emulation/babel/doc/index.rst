Testing a Linux Routing Daemon in a Simulated Environment
=========================================================

Goals
-----

Testing routing protocols with simulation is often easier than building a test
setup in the real world. INET's emulation features make it possible to use a
real-world routing protocol implementation in a simulated environment, where the
simulated environment and multiple instances of the real-world routing protocol
implementation can run on the same computer.

This showcase demonstrates such a test scenario with the Linux implementation of
the Babel routing protocol (Babel daemon). We'll run a simulation of a mobile ad
hoc network, where mobility and wireless connectivity will be simulated using
INET, and the routes will be managed by multiple instances of the Babel daemon.

Note that the emulation example only runs on Linux. For a comprehensive
understanding of emulation in INET, read the :doc:`Emulation section
</users-guide/ch-emulation>` in the User's Guide.

| INET version: ``4.1``
| Source files location: `inet/showcases/emulation/babel <https://github.com/inet-framework/inet/tree/master/showcases/emulation/babel>`__

The Model
---------

Babel is a reactive distance-vector routing protocol, similar to AODV or DSDV.
It is a robust and efficient routing protocol, suitable for both wired networks
and wireless mesh networks.
It works over IPv4/IPv6 and UDP.
The protocol's reference implementation is available for Linux as the Babel daemon
(``babeld``).

.. note:: The Babel daemon can be installed in Ubuntu and derivates with the following command:

          ``sudo apt install babeld``

We'll use INET's emulation support, namely Ext interfaces and :cpp:`RealTimeScheduler`,
to interface the simulation with services running on the host OS.

We test the Babel routing protocol in a simulated scenario. We build a wireless
ad hoc network,
where one of the hosts pings another.
The position and movement of the nodes, and the physical medium carrying the wireless
signals between them are simulated. The Ping requests are generated by a real Ping
application, the Ping replies by the real ICMP protocol,
and the routing protocol messages come from isolated instances of the real Babel daemon,
all running on the host OS. The protocol instances are separated by running them in
network namespaces on the host OS (network namespaces contain a complete virtualized
network protocol stack, independent from the real protocol stack in the host OS).
Each namespace has its IPv4 routing table that is managed by a Babel daemon
instance.

Configuration
~~~~~~~~~~~~~

The network contains one stationary and two mobile :ned:`AdhocHost`'s. The mobile hosts
are ``host[0]`` and ``host[2]``; they are configured to move around in circles, going in
and out of communication range with each other and the stationary host, ``host[1]``.
The Babel daemons will update the routes as connectivity changes between the three hosts.
The network is shown on the following image; the communication ranges are indicated with
blue circles, and the green movement trail circles show the path of the nodes.

.. image:: media/network4.png
   :align: center
   :width: 80%

The simulation and the real world is split at the wlan Ext interfaces in the hosts.
The following figure illustrates the emulation setup:

.. figure:: media/setup__.png
   :width: 90%
   :align: center

Each host has an :ned:`ExtUpperIeee80211Interface`. The interface contains an
:ned:`ExtEthernetTapDevice` module that has a corresponding TAP device created
in the host OS. The 802.11 radio, MAC and LLC are simulated; packets enter and
exit the TAP device above the LLC:

.. figure:: media/extinterface.png
   :width: 50%
   :align: center

In the host OS, we set up three network namespaces for the three hosts so that the
``babeld`` instances can run isolated from each other. Each network namespace has a
TAP device, and an IPv4 routing table. We use a real Ping application in ``host0``
to ping ``host2``. The Ping response is generated by the ICMP protocol in the
``host2`` network namespace.

.. Namespaces can be managed with shell scripts, but we can use the :ned:`ExternalEnvironment` and :ned:`ExternalProcess` modules to specify commands to run on the host OS from the ini file.
.. :ned:`ExternalEnvironment` can execute commands on the host OS at module creation and module destruction.
.. These commands can be specified by the :par:`setupCommand` and :ned:`teardownCommand` parameters.
.. We use these parameters to create and destroy network namespaces and virtual network interfaces in the host OS for the containing network node.
.. The :ned:`ExternalEnvironment` module can be included in hosts by setting the :par:`hasEnvironment` parameter to ``true``.
.. Another option is adding an :ned:`ExternalApp` module, which contains an :ned:`ExternalEnvironment` and an :ned:`ExternalProcess` submodule.

.. .. This module can be used to set up and tear down network namespaces and virtual network interfaces, for example.


.. .. V2 The :ned:`ExternalEnvironment` module deals with preparing the host OS environment
.. .. for running the emulation. Specifically, we use :ned:`ExternalEnvironment`'s :par:`setupCommand` and :ned:`teardownCommand` parameters
.. .. to create network namespaces and virtual network interfaces in the host OS for the containing network node.
.. .. As the name suggests, :par:`setupCommand` is executed at module creation, and :ned:`teardownCommand` at module destruction.
.. .. The ExternalEnvironment module can be included in hosts by setting the :par:`hasEnvironment` parameter to ``true``,
.. .. or adding an :ned:`ExternalApp` module; this module contains an :ned:`ExternalEnvironment` and an :ned:`ExternalProcess` submodule.

.. The :ned:`ExternalProcess` module can be used to execute commands in the host OS during the simulation.
.. We'll use it to start the babeld instances, and run a ping command in the network namespace of the ``host0`` node.
.. As mentioned above, it is part of the :ned:`ExternalApp` module.

.. Specifying commands with :ned:`ExternalEnvironment` and :ned:`ExternalProcess` modules (as opposed to running shell scripts, for example) makes
.. the simulation self-contained, so it is the only thing we need to start. Furthermore, commands associated with a network node can be logically grouped
.. by specifying them at the network node itself.

.. .. warning:: To use :ned:`ExternalProcess` and :ned:`ExternalEnvironment` modules in some linux systems (Ubuntu version 24.04, for example), an AppArmor profile is required for priviliges. You can add the profile with the following commands from the ``showcases/emulation`` folder:

..    .. code-block:: shell

..       sudo cp opp_run /etc/apparmor.d
..       sudo aa-enforce /etc/apparmor.d/opp_run
..       sudo aa-disable /etc/apparmor.d/opp_run

..    Note that setcap commands are also required:

..    .. code-block:: shell

..       sudo setcap cap_sys_admin=ep /path/to/opp_run
..       sudo setcap cap_sys_admin=ep /path/to/opp_run_release
..       sudo setcap cap_sys_admin=ep /path/to/opp_run_dbg



.. Three shell scripts in showcase's folder configure and control the
.. emulation in the host OS: ``Setup.sh``, ``Run.sh`` and ``Teardown.sh``.

.. ``Setup.sh`` needs to be run first to create the network namespaces and the TAP
.. devices for the three hosts. It also brings up the TAP interfaces, and assigns
.. IP addresses to them:

.. .. literalinclude:: ../Setup.sh
..    :language: bash

.. The script assigns the following IP addresses:

We assign the following IP addresses:

+------------+-------------+
| host0      | 192.168.2.1 |
+------------+-------------+
| host1      | 192.168.3.1 |
+------------+-------------+
| host2      | 192.168.4.1 |
+------------+-------------+

.. The TAP devices are assigned random MAC addresses by the host OS when they are created.



These network namespaces could be set up by shell scripts, but we can also use the
:ned:`ExternalEnvironment` and :ned:`ExternalProcess` modules to specify
commands to run on the host OS from the ini file. This makes the simulation setup self-contained (we don't need to run shell scripts). Also, this way the commands can be
grouped logically with the network node they are associated with.

In this simulation, we're using unshared user namespaces, so that processes started by these modules have their own separate user and group IDs, allowing them to act as root inside the namespace without affecting the host system.
This is useful because we can run commands without ``sudo``:

.. literalinclude:: ../omnetpp.ini
   :language: ini
   :start-at: unshare-
   :end-at: unshare-

The :ned:`ExternalEnvironment` module deals with preparing the host OS environment
for running the emulation, then cleaning up afterwards. Specifically, the module's :par:`setupCommand` is executed at module creation, and :ned:`teardownCommand` at module destruction.
We use these parameters to create and destroy network namespaces and virtual network interfaces in the host OS for the containing network node.
We include an :ned:`ExternalEnvironment` module in hosts by setting the :par:`hasEnvironment` parameter to ``true``:

.. As the name suggests, :par:`setupCommand` is executed at module creation, and :ned:`teardownCommand` at module destruction.

.. :ned:`ExternalEnvironment` can execute commands on the host OS at module creation and module destruction.
.. These commands can be specified by the :par:`setupCommand` and :ned:`teardownCommand` parameters.
.. This module can be used to set up network namespaces and virtual network interfaces.
.. We include this module in hosts by setting the :par:`hasEnvironment` parameter to ``true``:

.. literalinclude:: ../omnetpp.ini
   :language: ini
   :start-at: hasEnvironment
   :end-at: hasEnvironment

Then, we specify the setup and teardown commands, 
and set which network namespace to run them in (here, we use the node's full name):

.. literalinclude:: ../omnetpp.ini
   :language: ini
   :start-at: nodeFullName()
   :end-at: ip tuntap del mode tap dev tap0

The :ned:`ExternalProcess` module can be used to execute commands in the host OS
during the simulation. It is part of the :ned:`ExternalApp` module, which also contains an :ned:`ExternalEnvironment` submodule.

In :ned:`ExternalProcess`, the command to execute in the host OS is defined by its :par:`command` parameter. Here,
we use it to start the babel daemon process.

To set up the babel daemon instances in the hosts, we insert an :ned:`ExternalApp` module into them,
and use its :ned:`ExternalEnvironment` submodule to specify the babel-specific setup and teardown commands.
Then, we specify the command to start the babel daemon in the :ned:`ExternalProcess` submodule:

.. literalinclude:: ../omnetpp.ini
   :language: ini
   :start-at: numApps = 1
   :end-at: process.command

We also employ an :ned:`ExternalApp` module to start the ping command in ``host0``'s network namespace:

.. literalinclude:: ../omnetpp.ini
   :language: ini
   :start-at: numApps = 2
   :end-at: process.printStdout

.. warning:: To use :ned:`ExternalProcess` and :ned:`ExternalEnvironment` modules in some linux systems (Ubuntu version 24.04, for example), an AppArmor profile is required for priviliges. You can add the profile with the following commands from the ``showcases/emulation`` folder:

   .. code-block:: shell

      sudo cp opp_run /etc/apparmor.d
      sudo aa-enforce /etc/apparmor.d/opp_run
      sudo aa-disable /etc/apparmor.d/opp_run

   Note that setcap commands are also required:

   .. code-block:: shell

      sudo setcap cap_sys_admin=ep /path/to/opp_run
      sudo setcap cap_sys_admin=ep /path/to/opp_run_release
      sudo setcap cap_sys_admin=ep /path/to/opp_run_dbg

.. (:ned:`ExternalApp` contains both an :ned:`ExternalEnvironment` and
  an :ned:`ExternalProcess` submodule.)



.. which deals with preparing the host OS environment
.. for running the emulation. Specifically, we use :ned:`ExternalEnvironment`'s :par:`setupCommand` and :ned:`teardownCommand` parameters
.. to create network namespaces and virtual network interfaces in the host OS for the containing network node.
.. As the name suggests, :par:`setupCommand` is executed at module creation, and :ned:`teardownCommand` at module destruction.

.. Here is the configuration in omnetpp.ini where we configure the setup and teardown commands:

.. .. literalinclude:: ../omnetpp.ini
..    :language: ini
..    :start-at: 

.. The other submodule in :ned:`ExternalApp` is :ned:`ExternalProcess`. This module represents the process corresponding to the network node
.. during simulation. The command to execute in the host OS is defined by :ned:`ExternalProcess`'s :par:`command` parameter. Here,
.. we use it to start the babel daemon process. TODO namespace

.. These commands could be defined in shell scripts as well, however, defining them in an :ned:`ExternalApp`
.. however, defining commands associated with a network node in the simulation at the node itself makes
.. for logical grouping and running the simulation more convenient. For example, we can easily refactor
.. shared parts of the command by parameterizing network-node-dependent values such as node index.


.. ``Run.sh`` runs the emulation example; it starts the ``babeld`` instances, runs a
.. ``ping`` command in ``host0``'s network namespace each second, and opens the simulation in
.. qtenv. The user is expected to run the simulation in express mode. After qtenv is
.. closed, the script stops the Ping loop and the ``babeld`` instances:

.. .. literalinclude:: ../Run.sh
..    :language: bash

.. The ``Teardown.sh`` script can be run to destroy
.. the TAP interfaces and the network namespaces when they are not needed anymore:

.. .. literalinclude:: ../Teardown.sh
..    :language: bash

.. Note that commands involving network namespaces (netns) require root privileges.

Here is the Ext interface configuration in :download:`omnetpp.ini <../omnetpp.ini>`:

.. literalinclude:: ../omnetpp.ini
   :start-at: ExtUpperIeee80211Interface
   :end-at: copyConfiguration
   :language: ini

For each host, the configuration selects the corresponding TAP interface from the
network namespaces of the host OS, and copies its configuration, such as assigned
IP address and MAC address. Having matching addresses of the corresponding simulated
and real network interface parts is important because packets will contain and be handled
according to these addresses (the MAC might silently drop packets if the addresses
don't match).

It is also important to ensure synchronization between the host OS and the simulation
with ``RealTimeScheduler``:

.. literalinclude:: ../omnetpp.ini
   :start-at: General
   :end-at: sim-time-limit
   :emphasize-lines: 3
   :language: ini

For compatibility with the host OS's ``babeld`` and ``ping`` applications, the FCS mode
in the hosts' MAC module is configured to compute the FCS (as opposed to assuming
it to be correct):

.. literalinclude:: ../omnetpp.ini
   :start-at: fcsMode
   :end-at: fcsMode
   :language: ini

Also, for the sake of simplicity, we turn off everything that's not strictly required,
such as loopback interfaces and unused protocols:

.. literalinclude:: ../omnetpp.ini
   :start-at: numLoInterfaces
   :end-at: hasIpv6
   :language: ini

Accessing unshared network namespaces
-------------------------------------

Unshared network namespaces are not visible from the host OS environment as they are isolated (e.g. ``ip netns list`` doesn't list them).
However, they can be accessed based on Process ID (PID). The babeld processes export their PIDs to files (``babel*.pid``).
We can run the following command in a terminal to watch routing tables in the network namespace:

.. code:: shell

   watch -n 0.1 "sudo nsenter -t $(cat babel0.pid) -n ip route"

This enters the network namespace (``nsenter``) specified by the PID in ``babel0.pid``, and runs the ``ip route`` command to display the routing table.

Similarly, we can use Wireshark to monitor traffic on the virtual network interfaces; just replace the command with ``wireshark``:

.. code:: shell

   sudo nsenter -t $(cat babel0.pid) -n wireshark

.. note:: ``sudo lsns -t net`` can be used to list process IDs in unshared network namespaces.

Results
-------

The simulation can be started with the ``inet`` command from a terminal:

.. code:: shell

   inet

**TODO** cut video 10 seconds

Here is a video of the simulation running:

.. video:: media/babel.mp4
   :align: center
   :width: 100%

The simulation is shown running in qtenv on the left.
The first three terminals on the right display the routing tables of the three hosts
in the three network namespaces; we start the simulation from the fourth terminal; it also displays the Ping output.

Successful link-layer transmissions are visualized with arrows; green for Babel messages,
and red for Ping.

At first, the routing tables are empty. When the nodes move into communication range
with each other, the babel messages can be exchanged, and each ``babeld`` instance
adds routes to its routing table. The following route topologies occur between
``host[0]`` and ``host[2]`` during the simulation:

- There is no connectivity between ``host[0]`` and ``host[2]``
- ``host[0]`` can reach ``host[2]`` in one hop (via ``host[1]``)
- ``host[0]`` can reach ``host[2]`` directly

As the connectivity changes, the babel protocols adapts the routes. Note that the
route metric is 256/hop (256 when the address is reachable in one hop; 512 when two hops).
The metric is a very large number when unreachable.

The routes take a few seconds (and several babel message exchanges) to form.
They also expire after some time when there is no connectivity.

A Babel message opened in Wireshark is shown on the following image.
It is sent by ``host[0]`` at the beginning of the simulation when the route
between ``host[0]`` and ``host[2]`` forms for the first time:

.. figure:: media/babelmessage3.png
   :align: center
   :width: 90%

This Babel message broadcasts a route; it contains several `type-length-value`
elements (TLVs). The ``nh`` and ``update`` messages indicate that 192.168.4.1
(``host2``) can be reached via 192.168.3.1 (``host1``), in one hop (`metric=256`).

Sources: :download:`omnetpp.ini <../omnetpp.ini>`, :download:`BabelShowcase.ned <../BabelShowcase.ned>`


Try It Yourself
---------------

If you already have INET and OMNeT++ installed, start the IDE by typing
``omnetpp``, import the INET project into the IDE, then navigate to the
``inet/showcases/emulation/babel`` folder in the `Project Explorer`. There, you can view
and edit the showcase files, run simulations, and analyze results.

Otherwise, there is an easy way to install INET and OMNeT++ using `opp_env
<https://omnetpp.org/opp_env>`__, and run the simulation interactively.
Ensure that ``opp_env`` is installed on your system, then execute:

.. code-block:: bash

    $ opp_env run inet-4.6 --init -w inet-workspace --install --chdir \
       -c 'cd inet-4.6.*/showcases/emulation/babel && inet'

This command creates an ``inet-workspace`` directory, installs the appropriate
versions of INET and OMNeT++ within it, and launches the ``inet`` command in the
showcase directory for interactive simulation.

Alternatively, for a more hands-on experience, you can first set up the
workspace and then open an interactive shell:

.. code-block:: bash

    $ opp_env install --init -w inet-workspace inet-4.6
    $ cd inet-workspace
    $ opp_env shell

Inside the shell, start the IDE by typing ``omnetpp``, import the INET project,
then start exploring.


Discussion
----------

Use `this <https://github.com/inet-framework/inet-showcases/issues/46>`__ page in the GitHub issue tracker for commenting on this showcase.
