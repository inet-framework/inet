[General]

[Config Wireless01]
description = Two nodes communicating for 25s
network = WirelessA
# limit the simulation to 25s
sim-time-limit = 25s

# configure an aplication for hostA that sends a cosntant
# UDP traffic around 800Kbps (+ protocol overhead) 
*.hostA.numUdpApps = 1
*.hostA.udpApp[0].typename = "UDPBasicApp"
*.hostA.udpApp[0].destAddresses = "hostB"
*.hostA.udpApp[0].destPort = 5000
*.hostA.udpApp[0].messageLength = 1000B
*.hostA.udpApp[0].sendInterval = exponential(10ms)

# configure an app that receives the USP traffic
*.hostB.numUdpApps = 1
*.hostB.udpApp[0].typename = "UDPSink"
*.hostB.udpApp[0].localPort = 5000

# Let's configure ARP
# ARP is used to resolve the MAC address of a node from its IPv4 address.
# We do not want to use it in this wireless tutorial as it just adds
# some uninteresting message exchanges before the real communication
# between the nodes can start. We will use the GlobalARP module instead 
# that can automatically provide all the MAC-IP assocoations for the nodes. 
**.arpType = "GlobalARP"

# Configure the hosts to have a single "ideal" wireless NIC. An IdealWirelessNic
# can be configured with a maximum communication range. All packets withing range
# are always received successfully while out of range messages are never received.
# This is useful if we are not interested how the actual messages get to their destination,
# we just want to be sure that they get there once the nodes are in range.
*.host*.wlan[*].typename = "IdealWirelessNic"

# transmission speed for the "ideal" wireless nic.
*.host*.wlan[*].bitrate = 1Mbps

# mandatory mac layer parameters 
*.host*.wlan[*].mac.headerLength = 10B

# mandatory physical layer parameters
*.host*.wlan[*].radio.transmitter.headerBitLength = 100b
*.host*.wlan[*].radio.transmitter.maxCommunicationRange = 500m

# Simplify the IdealWirelessNic even further. We do not care even if there are
# transmission collisions. Any number of nodes in range can transmit at the same time
# and the packets will be still successfully delivered.
*.host*.wlan[*].radio.receiver.ignoreInterference = true

[Config Wireless02]
description = Set up some animations
extends=Wireless01

# Allow the medium to animate the transmissions using the OMNeT++ Canvas API
# (We no longer need the default message animation so let's turn it off manually
# in the Tkenv's animation settings dialog.)
*.radioMedium.mediumVisualizer.displayCommunication = true

# To have a bit more smoother animation, turn on periodic self messages 
# from the medium. This will generate canvas updates to animate the 
# transmission animation. Instead of seeing only important events, we will see 
# how the transmission propagates through space. 
*.radioMedium.mediumVisualizer.updateCanvasInterval = 100ns

# Allow the medium to draw a fading trail of successful transmissions (will show the communication paths).
*.radioMedium.mediumVisualizer.leaveCommunicationTrail = true

[Config Wireless03]
description = Add more nodes and decrease the communication range to 250m
extends = Wireless02
network = WirelessB

# Decrease the communication range so hostA and hostB can no longer
# communicate directly.	
*.host*.wlan[*].radio.transmitter.maxCommunicationRange = 250m

[Config Wireless04]
description = Set up static routing
extends = Wireless03

# enable static routing
*.host*.forwarding = true

# To have proper communication, we have to add static route entries in all hosts.
# It is too much work to do it manually so we instruct the network configurator 
# to use the estimated error rate between the nodes to set up static routes. 
# Nodes out of range will have an error rate of 1 while nodes within range 
# will have configurator.minLinkWeight error rate (by default it is 1e-3) 
# when using the IdealRadio. This will generate a properly configured IPv4 network 
# without any additional manual configuration.
*.configurator.config = xml("<config><interface hosts='**' address='10.0.0.x' netmask='255.255.255.0'/><autoroute metric='errorRate'/></config>")

# WARNING !!!! allowing the optimization results in an incorrect routing table in HostB
# the default interface gateway entry interferes with the optimized routes.
# it seems that the interface metric is not taken into the account either.
# By disabling the routing table entry optimization we will have a separate entry for
# each destination host. The routing tables will be longer, but they are much easier to
# understand.
*.configurator.optimizeRoutes = false

# Result: In reality we would expect that the throughput between the hosts drops
# becuase two nodes are using the medium at the same time with a datarate that is
# around the capacity of the medium. The example does not show this, because we
# have disabled the handling of the radio interference in step 1 (ignoreInterference = true)

[Config Wireless05]
description = Take into account the interference between different hosts
extends = Wireless04

# In this step we will try to more accurately model the communication by taking into account
# the interference betweeen transmissions at the radio receiver.
*.host*.wlan[*].radio.receiver.ignoreInterference = false

# Let's make the interference range the double of the communication range. 
*.host*.wlan[*].radio.transmitter.maxInterferenceRange = 500m

# Result: This change will result in an almost constant collision at hostB becuase both hostA and hostR1 is 
# transmitting at almost the capacity of the medium. The only packets that get through are 
# the ones that are sent from hostR1 to hostB while the hostA happens not to transmit by chance.
# Because of this, we are seeing and extremely low throughput.

[Config Wireless06]
description = Use CSMA for better use of the medium
extends = Wireless05

# We will use CSMA for the MAC so transmitters will sniff into the medium and will not
# transmit if there is an ongoing transmission in their interference range. 

# Let's switch the NIC to WirlessNic (from IdealWireless).
*.host*.wlan[*].typename = "WirelessNic"

# Still using IdealRadio. We have to set this, because the default radio for WirelessNic is Ieee80211.
*.host*.wlan[*].radioType = "IdealRadio"

# The MAC protocol is now CSMA
*.host*.wlan[*].macType = "CSMA"

### QUESTION: why the IdealWirelessNic and WirelessNic are separate? In optimal case IdealWirelessNic should be
### a parametrized version of WirelessNic.

### QUESTION: why dont we have a bitrate parameter for Wireless NIC (similarly to the ideal one?) right now we have to set it for the radio and for the mac too
*.host*.wlan[*].mac.bitrate = 1Mbps

# We need MAC acknowledgements to detect if a link is broken between two nodes
### QUESTION: why don't we have a default value for this parameter?
*.host*.wlan[*].mac.useMACAcks = true
### QUESTION: why don't we have a default for this value?
*.host*.wlan[*].mac.rxSetupTime = 0s
### ISSUE: CSMA mac's headerLength is specified in BITs while others in bytes.
*.host*.wlan[*].mac.headerLength = 72b

### It is strange that we have to set this parameter when we already set this on the NIC directly
### ISSUE: WirelessNIC does not pass the parameter further down to the mac and to the transmitter
*.host*.wlan[*].radio.transmitter.bitrate = 1Mbps

# Once CSMA is configured, we should see an increased throughput (compared to the previous step
# where the medium was not checked before transmission)

[Config Wireless07]
description = Configure node movements
extends = Wireless06

# Configure the relay nodes (R1-3) to move straight north during the simulation
# TIP: run the simulation in Fast mode to see some screen updates
*.hostR*.mobilityType = "LinearMobility"
*.hostR*.mobility.speed = 12mps
*.hostR*.mobility.angle = 270deg

# Result: we are seeig lower throughput than previously. This is because the
# static routing tables were configured based on the topology (node distances) at
# the beginning of the simulation. Data was routed from A to B through the R1 node.
# Unfortunately R1 node gets out of range around 13s and after that time the original 
# route is no longer usable. We could use A->R2->R3->B after this point, but that would 
# require an active protocol that reconfigures routing tables in response to the 
# lost connectivity.     

[Config Wireless08]
description = Configure adhoc routing (AODV)
extends = Wireless07

# Turn off the static configuration added by the IPv4NetworkConfigurator so it will not interfere
# with the dynamic routing protocol. We are only assigning IP addresses now
*.configurator.addStaticRoutes = false
*.configurator.addDefaultRoutes = false
*.configurator.addSubnetRoutes = false

# Let's use AODV by using AODVRouters in the network. See Wireless07
# While running the simulation we see that the communication is broken areound 13s
# and AODV re-establishes the routes through A->R2->R3->B around 16s
*.hostType = "AODVRouter"

### NOTICE: I don't like the way routing protocols are configured. Why don't we have a parameter
### to specify the type instead of a separate type for all routing types. 
### Protocols should implement the same interface. I.e. one of the: IRoutingTCP, IRoutingUDP, IRoutingIP

[Config Wireless09]
description = Install energy management into the nodes
extends = Wireless08

# Set up a model for the energy consumption of the nodes
**.energyConsumerType = "StateBasedEnergyConsumer"

# Configure an energy storage device (inifite energy). We are not interested
# in the actual storage behavior.
*.host*.energyStorageType = "IdealEnergyStorage"

# Result: We can check the energy use of a module by looking at the energyBalance value in the module
# (hostA.energyStorage.energyBalance) or it is possible to see the energy use
# over time by displaying the residualCapacity signal.

[Config Wireless10]
description = Add obstacles to the environment
extends = Wireless09
network = WirelessC

### XXX because of an incorrect default we should configure an empty object cache time for an infinite space environment (do we still need it)
# once this is fixed in INET the below line can be removed
*.environment.objectCacheType = ""

# Configure the physical environment to contain a single brick wall
*.environment.config = xmldoc("walls.xml")
*.radioMedium.obstacleLossType = "TracingObstacleLoss"

# Result: Unfortunately we don't see any difference. Our radio model is too simple to take into account 
# the objects in the environment.

[Config Wireless11]
description = Enhance the accuracy of the radio model
extends = Wireless10

# We switch to a more detailed radio model so we have to replace the global radioMedium module
*.mediumType = "APSKScalarRadioMedium"

# configure the background noise for the medium
*.radioMedium.backgroundNoise.power = -110dBm

### TODO: In best case this should not be provided by the user rather the medium should calculate this automatically from the radio frequency.
*.radioMedium.mediumLimitCache.carrierFrequency = 2GHz

# Configure each radio in the modell. (We need a lot more parameters to set up the radio)
*.host*.wlan[*].radioType = "APSKScalarRadio"
*.host*.wlan[*].radio.carrierFrequency = 2GHz
*.host*.wlan[*].radio.bandwidth = 2MHz
*.host*.wlan[*].radio.transmitter.power = 1.2mW
*.host*.wlan[*].radio.transmitter.bitrate = 1Mbps
*.host*.wlan[*].radio.transmitter.headerBitLength = 100b
*.host*.wlan[*].radio.receiver.sensitivity = -85dBm
*.host*.wlan[*].radio.receiver.energyDetection = -85dBm
*.host*.wlan[*].radio.receiver.snirThreshold = 4dB

[Config Wireless12]
description = Configure a more accurate pathloss model
extends = Wireless11

# To make our model even more acurate, let's configure the pathloss model, too.
# By default the medium uses the free space model. We will use the TwoRayGroundReflection model.
# (We could also configure the computation model for the medium (scalar, multidimensional)
# the propagation mode (constant speed, constant time) etc.
*.radioMedium.pathLossType = "TwoRayGroundReflection"
 
[Config Wireless13]
description = Enhance the antenna with some constant gain
extends = Wireless12
# let's install a better antenna to extend the range of the nodes
*.host*.wlan[*].radio.antennaType = "ConstantGainAntenna"
*.host*.wlan[*].radio.antenna.gain = 12dB

#ISSUE: unknown paramter

[Config Wireless14]
description = Add traffic to the neighbouring frequency channel
extends = Wireless13
# adding some noise on a neighbouring channel


















#############################################################################################
# not used
[Config Wireless06LMac]
# throws an error. Check with Levy!
extends = Wireless05

*.host*.wlan[*].typename = "WirelessNic"
*.host*.wlan[*].radioType = "IdealRadio"
*.host*.wlan[*].macType = "LMacLayer"

*.host*.wlan[*].mac.numSlots = 2
*.host*.wlan[*].mac.bitrate = 1Mbps

*.host*.wlan[*].radio.receiver.ignoreInterference = false
*.host*.wlan[*].radio.transmitter.maxInterferenceRange = 500m
*.host*.wlan[*].radio.transmitter.bitrate = 1Mbps
*.host*.wlan[*].radio.transmitter.headerBitLength = 100b

[Config Wireless06BMac]
extends = Wireless05

*.host*.wlan[*].typename = "WirelessNic"
*.host*.wlan[*].radioType = "IdealRadio"
*.host*.wlan[*].macType = "BMacLayer"

*.host*.wlan[*].mac.bitrate = 1Mbps

*.host*.wlan[*].radio.receiver.ignoreInterference = false
*.host*.wlan[*].radio.transmitter.maxInterferenceRange = 500m
*.host*.wlan[*].radio.transmitter.bitrate = 1Mbps
*.host*.wlan[*].radio.transmitter.headerBitLength = 100b


[Config Wireless06_80211MAC]
extends = Wireless05

*.host*.wlan[*].typename = "Ieee80211Nic"
*.host*.wlan[*].mgmtType = "Ieee80211MgmtAdhoc"
*.host*.wlan[*].radioType = "IdealRadio"

*.host*.wlan[*].radio.receiver.ignoreInterference = false
*.host*.wlan[*].radio.transmitter.bitrate = 1Mbps
*.host*.wlan[*].radio.transmitter.maxInterferenceRange = 500m
*.host*.wlan[*].radio.transmitter.headerBitLength = 100b

