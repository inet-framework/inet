2012-08-07  ------ inet-2.0.0 released ------

2012-06-25  ------ inet-1.99.5 released ------

2012-06-15  Zoltan Bojthe

	IPv4Route: removed RouteType type field, and getType(), setType()
	functions, too.

	IPv4InterfaceData: removed unnecessary ASSERT

2012-05-15  Tamas Borbely

	Added DSCP and ECN accessors to IPv4Datagram.

2012-03-28  Tamas Borbely

	IGMPv2: external routers attached to the IGMP module
	are now responsible for implementing the IGMP router
	logic (emiting queries and processing group membership
	reports).
	In this case the IGMP module passes all incoming IGMP
	messages to the external router.

2012-03-26  Tamas Borbely

	Fix: subnet directed broadcast did not work.
	When the router of the destination subnet received
	the datagram, it delivered the datagram locally, but
	did not forward it with a link layer broadcast.

2012-03-20  ------ inet-1.99.4 released ------

2012-03-09  Tamas Borbely

	Adapted the IGMPv2 (RFC 2236) implementation received in bug
	tracker entry #538 with the following modifications:

	1. The module is renamed to IGMPv2.
	2. Checksum field is deleted from IGMPMessage. Errors modeled
	   with the errorBit field of packets, and erroneous packets
	   are already dropped by the link layer.
	3. The state of the IGMP module (timers, state variables, flags)
	   are stored in the module itself instead of the IPv4InterfaceData.
	   Joined multicast groups and multicast listeners can be queried
	   from the IPv4InterfaceData though.
	4. cMessages are used as timers.
	5. Multicast routers connected to the IGMPv2 module will receive
	   only those IGMP packets not processed by the IGMP module itself.
	   The 'externalRouter' parameter has been replaced by the check
	   that routerIn/routerOut gates are connected.
	6. IGMP reports are not sent when joining or leaving link-local
	   multicast groups (224.0.0.x). These messages are superfluous,
	   because link-local multicast datagrams are never forwarded.
	7. Several bug fixes of state transitions of the hosts and routers.

	Tests for the IGMPv2 module can be found in the tests/module
	directory.

2012-03-08  Tamas Borbely

	Multicast forwarding is turned off by default ('forwardMulticast'
	parameter of RoutingTable). Only one example used multicast
	forwarding, and when turned on routers generate too much
	uninteresting IGMP traffic. Turn it on in multicast routers
	if you simulate multicast networks by setting the
	'forwardMulticast' parameter of Router modules.

2012-03-04  Andras Varga

	- Added a RoutingTableRecorder module that records all the changes
	  in the routing table to a file.
	- Better dump method for routing table.

2012-03-04  Levente Meszaros

	Fixed routing table change notifications.

2012-02-20  Tamas Borbely

	Added printMulticastRoutingTable() to IRoutingTable

2012-02-15  Tamas Borbely

	The multicastTtlThreshold field is added to IPv4InterfaceData.
	If the value is sent on an interface of a multicast router,
	it limits the scope of the multicast datagrams: datagrams
	with lower TTLs are not forwarded.

2012-02-14  Tamas Borbely

	Implement IP_MULTICAST_LOOP socket option.

	If IPv4ControlInfo.multicastLoop is true, then a copy of the
	sent multicast datagrams will be looped back to local sockets.
	The default value of the option is 'true'.

2012-02-14  Tamas Borbely

	Changes in IPv4 multicast routing:
	- We now use reverse path forwarding (routing entry contains
	  source address/mask, multicast group, parent (incoming) interface
	  and the set of child (outgoing) interfaces).
	- The new routing table enables to specify a separate multicast
	  routing tree per source network and multicast group. (Old
	  implementation used a common tree for each source.) The multicast
	  routing tree is represented by IPv4MulticastRoute entries.
	- IRoutingTable has been extended with methods manipulating the
	  multicast routing entries. Notifications are generated, when
	  the multicast routing table changes.
	- IPv4 multicast routing algorithm uses the multicast routes
	  for forwarding decisions.
	- When HL does not specify the multicast interface for outgoing
	  datagrams, then it is selected according to the routing table
	  or the source address of the datagram.

	Change from previous behavior:
	- packets sent to a multicast address from higher layer: it used
	  to go out on each interface that had a matching route in the
	  routing table (unless mcast interface was specified by HL).
	  Now it only goes out on the first match route's interface;
	  if there's no match it goes out on the 1st multicast interface
	  (unless mcast interface was specified by HL). If you want to
	  send on multiple interfaces, you have to send multiple packets
	  from the higher layer.

	- multicast forwarding: no longer takes into account the routes
	  in the unticast routing table that have mcast destinations.
	  Only the (new format) multicast table is used. This new
	  multicast routing table can only be configured with
	  IPv4NetworkConfigurator, routing files don't support it.

2012-02-09  Tamas Borbely

	Now ARP maps multicast IPv4 addresses to multicast MAC addresses
	according to RFC 1112 section 6.4. Before this change the ARP
	translated the multicast addresses to Ethernet broadcast
	(FF:FF:FF:FF:FF:FF) address. The MAC module does not filter
	the multicast frames though, so IP modules receives the same
	number of datagrams as earlier.

2012-02-09  Tamas Borbely

	Fix: if an interface joined to a multicast group, then IP passed up
	all multicast datagrams that was addressed to that group and reached
	the node. This is wrong, because only those datagrams should be
	delivered that arrived on an interface joined to the group.

2012-02-09  Tamas Borbely

	Multicast interfaces always join to the 224.0.0.1 (all systems)
	link-local multicast group on startup. In routers they join to the
	224.0.0.2 (all routers) group too.

2012-02-24  ------ inet-1.99.3 released ------

2012-02-19  Andras Varga

	IPv4Datagram: diffServCodePoint field has been changed to typeOfService

2012-01-12  Andras Varga

	RoutingTable: added getHostModule() method

2012-01-30  Tamas Borbely

	IPOption values have been updated to conform to the IP option types
	specified in RFC 791.

	IPv4: removed loose and strict source routing processing. These
	options are not used in the INET codebase, and the implementation
	did not work anyway. Moreover use of these options is deprecated,
	because they are causing security vulnerabilities.

2012-01-27  Tamas Borbely

	Fix: IPv4 does not change the destination address of locally delivered
	multicast datagrams. (It was overwritten with a local address before.)

2012-01-19  Tamas Borbely

	IPv4: report numLocalDeliver correctly.

	IPv4 accepts datagrams with unspecified source address. Needed for
	supporting e.g. DHCP.

	IPv4 fix: broadcast messages sent by the higher layer are forwarded to
	the loopback interface, so applications on the same node will receive it.

	IPv4: packets sent by a higher layer protocol to a local address
	are forwarded to the loopback interface internally. Therefore
	the MTU of the loopback interface has effect.

2012-01-20  Andras Varga

	RoutingTable: documentation refined

2012-01-19  Andras Varga

	IPv4Route: member variables changed from "protected" to "private"
	so that subclasses cannot bypass the change notification mechanism

2012-01-19  Andras Varga

	RoutingTable: "host" in IPv4Route renamed to "destination"
	(getHost() -> getDestination(), setHost() -> setDestination(), etc.)

2012-01-09  Andras Varga

	RoutingTable: implemented change notification for IPv4Route. Now
	IPv4Routes no longer have to be treated as immutable. Any field can
	be changed at any time; RoutingTable will notice the change and
	update its internal tables.

	RoutingTable will also fire a NF_IPv4_ROUTE_CHANGED notification (new).

	IPv4Route pointers returned by RoutingTable are no longer const.

	Also: added removeRoute() method to RoutingTable.

2012-01-13  Zoltan Bojthe

	IRoutingTable, RoutingTable: removed unused findRoute() and related
	routeMatches() functions

	RoutingTable: optimized purge() and deleteInterfaceRoutes()
	mathods: search in multicastRoutes too; optimize
	- call invalidateCache() and updateDisplayString() only once
	- do not search entry again, we know the iterator of deleted entry
	- use returned iterator of erase(), do not restart search

	RoutingTable: added missing isValid() checks to routing entry search
	functions (findRoute(), getMulticastRoutesFor(), getDefaultRoute())

	RoutingTable: optimizations on addRoute(), getDefaultRoute(), etc.

	RoutingTable: refactored deleter functions

2012-01-09  Zoltan Bojthe

	RoutingTable: moved DSDV-related fields/functions to DSDV. DSDV route
	expiry is now implemented with a new isValid() method on IPv4Route;
	RoutingTable will ignore invalid routes (isValid()==false).

	Details:
	- remove DSDV related fields/functions from the IPv4Route, IRoutingTable,
	  and RoutingTable classes
	- added new DSDVIPv4Route class that extends IPv4Route with DSDV-related
	  fields: expiryTime, sequencenumber (changed installtime to expirytime)
	- add IPv4Route::isValid() that compares simTime() to expiryTime
	- rename dsdvTestAndDelete() in RoutingTable to purge() -- it throws out
	  invalid routes using isValid()
	- remove set/getTimeToLiveRoutingEntry() functions from IRoutingTable
	- DSDV changed to add entries to the routing table with 255.255.255.255 netmask
	- DSDV to use DSDVIPv4Route entries

2012-01-09  Zoltan Bojthe

	RoutingTable: remove manet-related hacks (they were there to ensure
	routing cache consistency when manet routing protocols changed routes
	behind RoutingTable's back; and also to fake 255.255.255.255 netmask
	for manet routes whatever netmask IPv4Route actually contained.)

2012-01-09  Zoltan Bojthe

	RoutingTable: bugfix for bad check for host has 1-bits only inside
	netmask

2012-01-09  Zoltan Bojthe

	RoutingTable: store route entries ordered by netmask DESC, host ASC,
	metric ASC. This provides better performance (first match vs having to
	search through all routes to find the longest match).

	This is also a bugfix: old code didn't use the "metric" field to
	determine the best route.

2011-12-20  Zoltan Bojthe

	IPv4: bugfix for #463: IPv4: missing ICMP errors

	When delivering a datagram locally, but the protocol is not mapped to a
	transport layer gate or the gate is not connected, then generate an
	ICMP error with type=DESTINATION_UNREACHABLE, code=PROTOCOL_UNREACHABLE

2011-12-15  Zoltan Bojthe

	IPv4 bugfix #467: RoutingTable::invalidateCache() should delete
	localBroadcastAddresses too.

2012-01-18  Zoltan Bojthe

	IPv4 bugfix #457: throw error when a datagram is received from the
	network without source address

2011-12-20  Zoltan Bojthe

	IPv4 bugfix for #459: there is no fragmentation on the loopback
	interface

	Solution: drop packet and send ICMP if DontFragment bit of packet set
	and packet length bigger than MTU

	Bug was: If a packet is transmitted through the loopback interface, then
	is delivered directly, and the fragmentation method is not called. The
	loopback interface has an MTU, that should be respected by the IPv4
	module.

2011-12-14  Zoltan Bojthe

	IPv4 bugfix for #461: IPv4 fragmentation performance improvement

	The TTL==0 condition is checked in the IPv4::sendDatagramToOutput()
	method. It should be checked at the beginning of fragmentAndSend(),
	because there is no sense to create the fragments and dropping them one
	by one.

2011-12-14  Zoltan Bojthe

	IPv4 bugfix #425: fragmentation bugs

	The following issues were fixed:

	1. 'Fragment Offset' used as an arbitrary byte offset in the 0..65535
	   range. The IP header actually stores the 1/8 of the offset as a 13-bit
	   integer. Therefore the fragmentation code should ensure that the length
	   of the fragments (except the last one) is a multiple of 8. In addition,
	   the header serializer/deserializer should divide/multiply by 8 when
	   copying to/from external datagrams.

	2. The IPv4Serializer::serialize() method does not set the DF and MF
	   bits explicitly, but they obtain values from the higher bits of
	   fragmentOffset field of the IPv4Datagram!

	3. The IPv4::fragmentAndSend() method generates wrong fragmentOffset and
	   moreFragments values when the fragmented datagram is a fragment itself.
	   It always starts the fragmentOffset from 0, and clears the moreFragment
	   flag of the last generated fragment. However if the original datagram
	   is a fragment having fragmentOffset > 0, then the offsets of the new
	   fragments should start from that fragmentOffset. Similarly if the
	   original datagram has moreFragment bit set, then its fragments
	   (including the last one) also should have moreFragment bit set.

2011-12-14  Zoltan Bojthe

	IPv4: remove unused version of fragmentation (NEWFRAGMENT was never
	defined)

2011-11-18  ------ INET-1.99.2 released ------

2011-10-14  Zoltan Bojthe

	adds missing dup()

2011-11-13  Levente Meszaros, Zoltan Bojthe

	Refactored operator= and copy constructor in all INET classes.
	See base/ChangeLog for details.

2011-11-11  Tamas Borbely

	#bug 366: IPv4 does not route broadcast messages?

	  patch suggested by the reporter of the bug + memory leak fix

2011-09-12  Zoltan Bojthe

	patch #392: IPv4 ICMP Error Watches

	Added some watches for host unreachable and time exceeded. Written by
	jesjones

2011-08-02  Zoltan Bojthe

	fixes for cppcheck

2011-07-24  Andras Varga

	cosmetics

2011-07-24  Andras Varga

	IPv4InterfaceData: added joinMulticastGroup()/leaveMulticastGroup()

2011-07-19  Andras Varga

	cPolymorphic -> cObject (cPolymorphic became cObject in OMNeT++ 4.0)

2011-07-06  Zoltan Bojthe

	IPv4: remove noise from code

2011-06-14  Rudolf Hornig

	removed ip rules support and moved to a separate branch

2011-06-10  Zoltan Bojthe

	cosmetics: code style, remove some codes in comments

2011-06-03  Andras Varga

	cosmetics: space usage made somewhat more consistent throughout the code

	Notes:
	- if you have an INET fork and want to compare the code, use the
	 "Ignore spaces" option of your visual diff tool. Most tools have
	 this option; Meld and Araxis Merge certainly do.

	- I used omnetpp/_scripts/tidymodel/spaces.pl, plus some manual tweaks

2011-05-30  ------ INET-1.99.1 released ------

2011-05-27  Andras Varga

	tab-to-space in all source files

2011-05-26  Zoltan Bojthe

	include optimisation, code style

2011-05-26  Zoltan Bojthe

	Bugfix: IPv4FragBuf segfault

	also:
	- fix IPFragBuf test
	- code style changes

2011-05-26  Zoltan Bojthe

	Renamed IP... classes to IPv4... or IPvX...

2011-05-11  Rudolf Hornig

	Moved header serializers to the util directory.

2011-05-11  Rudolf Hornig

	Renamed tpc_inet -> tcp and tcp_base -> tcp_common. TCP Base feature
	renamed to TCP Common

2011-04-27  Zoltan Bojthe

	sprintf fixes

2011-04-27  Rudolf Hornig

	INET now compiles with MANET turnened off.

2011-04-20  Rudolf Hornig

	Initial takeover of MANET routing protocols from INETMANET.

2011-04-18  Rudolf Hornig

	BGP: Use IF table to determine my AS id.

2011-04-07  Rudolf Hornig

	Fix: display the network address instead of the ip address in the
	routing table in the automatically generated rules for the interfaces.

2011-03-30  Zoltan Bojthe

	changes on wireless nodes, remove deprecated nodes

2011-03-09  Zoltan Bojthe

	IP Protocol ID constants

2011-03-09  Zoltan Bojthe

	Features: IPv4

2011-03-03  Zoltan Bojthe

	features: TCP_NSC, TCP_lwip, IPv6 completed

2011-03-03  ------ INET-1.99.0 released ------

2011-03-02  Zoltan Bojthe

	change opp_error to throw cRuntimeError

2011-02-25  Zoltan Bojthe

	fix: cannot use "%d" format for size_t on 64-bit systems; use '<<' instead

2011-02-24  Zoltan Bojthe

	Eliminate compile warnings

2011-02-22  Andras Varga

	Swiched NED documentation comments to explicit hyperlinking of NED
	type names, using tilde. Example: "TCP" was changed to "~TCP"
	wherever the module and not the protocol was meant.

	The reason for the switch was that autolinking produced too many
	false hits (e.g. "TCP connection" and "IP address" would link
	to the TCP and IP modules.)

2011-01-13  Zoltan Bojthe

	using getEncapsulatedPacket() instead deprecated getEncapsulatedMsg()

2010-06-21  Zoltan Bojthe

	indent changes - from Thomas Reschka

2009-12-21  Andras Varga

	fix: IP: fragmentOffset and moreFragments header fields were not cleared
	on reassembled datagrams; fix typo [reported by vire]

2009-11-05  Rudolf Hornig

	Changes related to the TCP-SACK implementation from Thomas Reschka.

2009-08-26  Andras Varga

	minor refactoring: introduced
	IPv4InterfaceData::isMemberOfMulticastGroup(mcastAddr)

2009-08-12  Andras Varga

	fix for "decapsulate(): length became negative" error when an IP
	datagram fragment times out and gets sent back to UDP in an ICMP error.

2009-07-19  Andras Varga

	added further module @labels (ethernet-node, wireless-node, mpls-node);
	added default icons to several module types

2009-07-17  Levente Meszaros

	Added labels to gates to so that the graphical editor can match them
	when the user creates a connection:

	@labels(EtherFrame); labels(Ieee802Ctrl/up); labels(Ieee802Ctrl/down);
	@labels(TCPCommand/up); @labels(TCPCommand/down);
	@labels(UDPControlInfo/up); @labels(UDPControlInfo/down);
	@labels(Ieee80211Frame);  @labels(IPControlInfo/down);
	@labels(IPControlInfo/up);  @labels(IPDatagram);
	@labels(IPv6ControlInfo/up); @labels(IPv6ControlInfo/down);
	@labels(IPv6Datagram)

2009-03-25  ------ INET-20090325 released ------

2008-09-09  Tamas Borbely

	* IP: set timeToLive to 1 if the destination is isLinkLocalMulticast() to
	prevent broadcasting to non-neighbouring routers.

2008-07-08  Andras Varga

	* RoutingTable: implemented routing cache [code based on OverSim
	patch]; similar performance optimization for isLocalAddress()

	* IP: performance: remember outputQueue gate pointer instead of
	looking up the gate by name for each send(). Note: could do the
	same optmization for other gates as well, but this gate is much
	more often used than the others

2008-07-07  Andras Varga

	* introduced IRoutingTable, to allow users implement their own
	RoutingTables and plug them into INET simulations, without any
	change to the base INET.

2008-07-02  Andras Varga

	* RoutingTable: properly fire notifications on routing table changes

2008-07-01  Andras Varga

	* wrapped naked data members of IPv4Route into getters/setters

	* RoutingTable: enforce by returning "const" pointers that routes
	already added cannot be changed any more (one must delete and
	re-add it)

2008-06-23  Andras Varga

	* renamed RoutingEntry to IPv4Route

2008-06-29  Andras Varga

	* IP: factored out a createIPDatagram method

2008-01-01..2009-03-25  Andras Varga, Rudolf Hornig

	Porting of INET to OMNeT++ 4.0, and some general face lift:
	* better directory structure (names changed to lowercase; moved sources
	  under src/; better names, e.g. networkinterfaces -> linklayer)
	* build system to use a deep makefile
	* updated the C++ code for the 4.0 API (follow name changes; use
	  int64-based simtime_t; use cPacket; etc.)
	* NED files converted to 4.0 syntax
	* make use of new features in NED files (module interfaces, inout
	  gates, @unit, etc.)

2005-10-28  Andras Varga

	* IP.cc: obey new "outputPort" field of IPControlInfo when sending
	multicast datagram

	* RoutingTableParser.cc: 5th field of a route in routing files is
	the metric (so far it was "preferences" but in fact it was unused)

2005-07-06  Andras Varga

	* IP.cc: don't forward "link-local" multicast addresses (224.0.0.x)

2005-07-04  Andras Varga

	* RoutingTable: localDeliver() ignores interface netmask [reported by
	Michael Tuexen]

	* RoutingTable: interface netmask functionality is now achieved by
	routes of type IFACENETMASK added to the routing table. These routes
	are re-built whenever notification is received that there was a change
	in the interface IPv4 configurations.

2003..2004  Andras Varga

	Created the initial version of the INET Framework. The following text
	is a minimally edited version of the following Wiki pages:

	http://ctieware.eng.monash.edu.au/twiki/bin/view/Simulation/IPSuiteLogOfChanges
	http://ctieware.eng.monash.edu.au/twiki/bin/view/Simulation/IPSuiteChangesOld

	[Between February and October of 2003, Andras Varga was visiting Monash
	University in Melbourne, Australia on the invitation of Dr Ahmet
	Sekerciouglu; much of the following work was done during this stay.]

	Fourth round: New features (August 2004-)
	=========================================

	   * Ethernet model integrated; new example simulation ARPTest

	   * TCP connections made inspectable in Tkenv

	   * TCP application models replaced with ones belonging to the new TCP,
	     and using TCPSocket, TCPSocketMap and IPAddressResolver.

	   * added simple IP address autoassignment and autorouting, to
	     eliminate need for writing routing tables by hand. Esp. useful for
	     large scale simulations. This currently supports a simple case
	     ("flat" routing, i.e. everything is a single network without subnets).
	     You only need to put a simple module called FlatNetworkConfigurator
	     into the network, and it'll auto-assign IP addresses to all interfaces,
	     and set up static routes. NO NEED TO WRITE A SINGLE IRT FILE!
	     For more sophisticated cases (hierarchial routing i.e. subnetting)
	     someone (or I) can write a different configurator module.
	     Example model (FlatNet) can be just run with a minimal omnetpp.ini
	     and without any .irt file or any other config file. Addresses and
	     routing tables are set up automatically.

	Third round: Ethernet and other network interfaces, TCP rewrite, architectural
	changes (April-August 2004)
	==============================================================================

	Separated old code which will no longer be maintained
	-----------------------------------------------------

	   * created Unsupported/ directory, and moved old TCP model, Socket,
	     their example models and applications in there.

	All-in-one IP
	-------------

	   * created a new, all-in-one IP model instead of very modular IPProcessing.
	     (It consisted of separate PreRouting, Routing, IPSend, IPMulticast, ...
	     modules). Using too many modules was a memory and CPU hog, and also
	     made code understanding/maintenance more difficult. (Old IPProcessing
	     also retained for experimentation with IP internals).

	IP revision
	-----------

	   * fragmentation reassembly buffer from the old code (LocalDeliver)
	     rewritten (both in the all-in-one IP and in LocalDeliver)

	   * RoutingTable completely revised. New class interface provides
	     better support for future routing protocols to modify the routing table.
	     Network interface entries in RoutingTable are no longer created based
	     on the .irt file (which could easily be inconsistent with what
	     L2 modules were actually present in the router/host compound module),
	     but they're dynamically registered by L2 modules such as PPPModule.
	     .irt file entries only configure them. (Configuration is not always
	     necessary though, e.g. PPPModule can register the interface with good
	     defaults for MTU and metric.)

	   * made interface tables and routing tables inspectable in Tkenv

	RSVP-TE
	-------

	Removed IPSuite dependency on libXML: RSVPApp was changed to use XML config
	file support of OMNeT++ 3.0a6 (class cXMLElement).

	Ethernet integration
	--------------------

	Checked in EtherNet model under NetworkInterfaces/Ethernet. Stuff common
	to IEEE 802 LANs put in the NetworkInterfaces/_802 directory.

	Implemented ARP (NetworkInterfaces/ARP directory).

	TCP rewrite
	-----------

	See TCP's ChangeLog.

	Convergence with TKN Mobility Framework
	----------------------------------------

	The idea of the blackboard comes from the Mobility Framework (MF).
	The MF will (hopefully) provide mobility and physical channel models.

	Current MF code is available from the omnetpp.org download area.

	Blackboard
	----------

	Blackboard module added to host and router models. The blackboard (BB)
	is for sharing information among several protocol layers (simple modules)
	in a publish-subscribe manner. Change notification is done via direct
	method calls.

	Typical usage pattern looks like this:

	   1. items are published on the blackboard, typically in initialize()

	   2. several modules may find it on the blackboard and subscribe to it.
	      Typically also in initialize() (multi-stage initalization will be
	      needed to ensure subscriptions follow publishing)

	   3. whenever a module (usually but not necessarily the subscriber)
	      modifies the item (or replaces it with another instance), it
	      tells the blackboard about this (changed()), and the blackboard
	      in turn notifies every subscriber (calls blackboardItemChanged()
	      in them). This step will occur very often in the simulation.

	   4. during simulation, modules may publish new items on the BB,
	      others may subscribe or unsubscribe, or items can be withdrawn
	      from the BB (which means auto-unsubscribing everyone subscribed
	      to it, because the BB completely forgets the item). However,
	      in typical use there'll be few such runtime publish/withdraw
	      or subscribe/unsubscribe operations (they'll usually occur
	      if there's some big change in the configuration.)

	"InterfacePacket" replaced by "Control Info" approach
	-----------------------------------------------------

	When packets are sent between protocol layers, usually there's some
	extra info to be attached to the packet. E.g. when a transpont layer
	protocol wants to send a transport packet over IP, in addition to sending
	the transport packet to IP it also has to tell the IP layer the
	destination IP address. The original approach in IPSuite was the use
	of "Interface Packets": the transport packet was wrapped (encapsulated)
	in a control message which contained the extra info (IPInterfacePacket
	message class).

	The current OMNeT++ 3.0 alpha offers a better way: messages can be
	attached a piece of "control info". Control info is a (typically struct-like)
	object subclassed from cPolymorphic. Control info classes can be described
	in a msg file. Examples:

	// needs to be attached to packets to be sent over IP; IP modules will use
	// this info for encapsulating the packet into an IPDatagram
	class IPControlInfo
	{
	    fields:
	        IPAddress srcAddress; // optional
	        IPAddress destAddress;
	        short protocol  enum(IPProtocolFieldId);
	        ...
	}

	// IP routing attaches this info to IP datagram:
	class IProutingDecision
	{
	    fields:
	        int interfaceNumber;
	        IPAddress nextHopAddress; // optional; used e.g. on LANs to find router
	}

	// Ethernet expects this to be attached to packets from higher layer:
	class _802ControlInfo
	{
	    fields:
	        MACAddress src; // optional
	        MACAddress dest;
	        ...
	};

	Three new methods have been added to cMessage for attaching, accessing
	and removing control info:

	   * void setControlInfo(cPolymorphic *p) -- attaches a "control info"
	     structure (object) to the message. The "control info" object
	     will be deleted when the message is deleted. Only one "control info"
	     structure can be attached (a second call to setControlInfo() will
	     throw an error).

	   * cPolymorphic *removeControlInfo() -- removes the "control info"
	     structure (object) from the message and returns its pointer.
	     Returns NULL if there was no control info in the message.

	   * cPolymorphic *controlInfo() const -- returns pointer to the
	     attached "control info"

	For sending a packet in an IP datagram, one has to fill in and attach
	control info to the message, and send the packet to IP. Like this:

	   cMessage *msg = ...

	   IPControlInfo *controlInfo = new IPControlInfo();
	   controlInfo->setProtocol(IP_PROT_TCP);
	   controlInfo->setDestAddr(destIPAddress);
	   packet->setControlInfo(controlInfo);

	   send(msg,"to_ip");

	And upon reception, it is possible to obtain the source IP address etc.
	like this:

	...::handleMessage(cMessage *msg)
	{
	   IPControlInfo *controlInfo = check_and_cast<IPControlInfo *>(msg->removeControlInfo());
	   IPAddress srcAddr = controlInfo->srcAddr();
	   IPAddress destAddr = controlInfo->destAddr();
	   delete controlInfo;
	   ...

	Second round: thorough code revision (Feb-March 2004)
	=====================================================

	IPSuite mainly has to be revised because OMNeT++ has made some progress
	since the IPSuite was written, and now it can offer much better solutions
	to some common programming tasks. Msg files got introduced, error handling
	changed, and we have now more experience how things should (or should not)
	be done.

	The focus is on some generic refactoring first, first in the network layer.
	Transport layer, apps, and L2 protocols come later. Adding of new features
	comes last. The original IPSuite was written with a sound architecture and
	in most places with careful programming, so most changes can be done almost
	automatically.

	ProcessorManager removed
	------------------------

	We now know that large-scale simulations can only be programmed using
	handleMessage(), because activity() just consumes too much memory.
	(Also, handleMessage() tends to force a clearer programming style and
	a more careful design.) ProcessorManager had to be removed because
	it is unsupportable with activity().

	Parameter assignments moved from NED to omnetpp.ini
	---------------------------------------------------

	In omnetpp.ini they are a lot easier to change, e.g. for a set of
	simulation experiments. The parameters in question were "..._delay"
	parameters and the ones defining QoS hooks (the latter was redesigned
	anyway, see following items).

	    parameters:
	      // processing delay times
	      ipoutput_delay = 0.1 us,
	      fragmentation_delay = 0.1 us,
	      ipsend_delay = 0,
	      localdeliver_delay = 0,
	      prerouting_delay = 0,
	      ...

	Confusing and unnecessary parameters killed
	-------------------------------------------

	Deleted otherwise very popular "nodename" and "nodenr" parameters
	because they weren't used for any meaningful purpose anywherec (just
	printed out in ev<<, but fullPath() is just as good for this purpose).

	Excessive parameter passing in NED files removed
	------------------------------------------------

	Some NED parameters were passed from simple module level up several
	compound module levels. I didn't find an obvious advantage for this
	parameter passing in many cases, so I removed these assignments
	(eliminated parameters from higher-level compound modules),
	and parameters should get values from omnetpp.ini, using wildcards.

	Link layer separated from Network Layer
	---------------------------------------

	Network interfaces removed from the compound module NetworkLayers,
	and moved up to node level. MPLS immediately fell in place (between
	L2 and L3) and MPLS2IP got thrown out.

	Also thrown out various flavours of router and host models that
	were very similar to each other.

	Removed "hooks" while preserving QoS functionality
	--------------------------------------------------

	The problem with QoS hooks in the Network layer was that:

	   1. All "core" modules (sendCore, localDeliverCore, preRoutingCore,
	      routingCore, ipOutputCore) were implemented with activity(),
	      which is a serious limitation in scalability. It would be good
	      to get rid of *all* activity() functions in IPSuite

	   2. they all used receiveOn() which has been deprecated for
	      a while and got removed in 3.0, together with putAsideQueue
	      they're based on.

	When rewritten with handleMessage(), the current logic of "core" modules
	would result in a complex logic. It had to be simplified.

	Decision: QoS hooks should NOT be separate modules at all. They
	should be just plain classes derived from an abstract base class,
	and used inside the "core" modules. This could be easily done, and we
	also kept the ability to select specific QoS behaviors from omnetpp.ini.

	Thus, in the IPSuite modules the old "core+hook" compound modules were
	eliminated and just replaced by the "core" modules which had the "Core"
	dropped from their names. E.g PreRoutingCore became PreRouting, and
	the old PreRouting compound module was removed.

	To illustrate the solution really briefly: to create a new QoS behavior,
	one has to subclass from the following class and redefine 2 functions:

	/**
	 * Abstract base class for enqueue hooks.
	 */
	class EnqueueHook
	{
	  public:
	    /**
	     * Called when a packet arrives and queue is not empty.
	     * Implementation of this function should enqueue the packet --
	     * or just discard it. It can also do priority queueing or
	     * discard other packets already in the queue -- anything.
	     */
	    virtual void enqueue(cMessage *msg, cQueue& queue) = 0;

	    /**
	     * Called when a packet arrives and the queue is empty.
	     * Implementation of this function should either return the same
	     * pointer, or drop the packet and return NULL.
	     */
	    virtual cMessage *dropIfNotNeeded(cMessage *msg) = 0;
	};

	Non-QoS implementation is just this:

	class EnqueueWithoutQoS : public EnqueueHook
	{
	    void enqueue(cMessage *msg, cQueue& queue) {
	        queue.insert(msg);
	    }
	    cMessage *dropIfNotNeeded(cMessage *msg) {
	        return msg;
	    }
	};
	Register_Class(EnqueueWithoutQoS); // needed to make class visible for createOne()

	By creating other EnqueueHook subclasses one can probably implement
	any needed QoS behavior.

	Modules that need QoS simply have to be derived from the module class
	QueueBaseWithQoS. Then it will automatically have a module parameter
	called "qosBehaviorClass", and QoS will automatically be handled by the
	base class QueueBaseWithQoS.

	simple PreRouting
	  parameters:
	     qosBehaviourClass: string;
	   ...
	endsimple

	Via "qosBehaviourClass", QoS behavior can be specified from omnetpp.ini.
	In the simplest case you have to put this line into omnetpp.ini:

	*.qosBehaviorClass = "EnqueueWithoutQoS"

	Internally, QueueBaseWithQoS holds an EnqueueHook pointer, and
	instantiates the QoS class via

	    enqHook = createOne(par("qosBehaviourClass"));

	OutputQueue simplified
	----------------------

	This compound module in the old form was quite complex (4 submodules),
	but (when not using QoS) acted effectively as a simple FIFO. Now it
	has been virtually eliminated -- it just consists of an in --> out
	connection (and no submodules at all). NWI_IDLE messages coming
	from the network interfaces are now ignored.

	OutputQueue will be refined -- we'll see how much it'll be needed
	at all. Comments welcome.

	Unified IP address representation
	---------------------------------

	Got rid of various classes and typedefs that all represented IP
	addresses: IPAddrChar (was char *), IPAddressParameter (was another
	char *), IN_Addr (was a class).  Now there's only IPAddress.

	IN_Port (was a class) also eliminated -- replaced by typedef
	short PortNumber.

	Cut sizeof(IPAddress) from 68 bytes (!!!!!) down to 4 bytes.

	IPAddress header file renamed from "ip_address.h" to "IPAddress.h".

	Handling error conditions
	-------------------------

	It often made debugging and discovering errors hard that at some places
	the code "concealed" and tried to locally repair error conditions
	instead of properly reporting them -- or just printed the error
	via ev<< which is hard to notice while the simulation is running.
	This was changed to opp_error() in many places.

	Replacing cMessage+cPar and hand-coded message classes with .msg files
	----------------------------------------------------------------------

	Done so far: IPInterfacePacket, IPDatagram, ICMPMessage, UDPPacket,
	UDPInterfacePacket. Next will come MPLS and LDP messages.

	cMessage-based ICMP message sending eliminated altogether (see next item).

	Sending of ICMP errors
	----------------------

	In the IPProcessing module, most modules (PreRouting, Routing,
	Fragmentation, IPOutput) were connected to ICMP via an errorOut gate,
	and on error condition they sent a cMessage (with cPars) to ICMP,
	to ask it to send an ICMP error packet. This mechanism was replaced
	by direct method call of the ICMP module, e.g. in PreRouting:

	   icmpAccess.get()->sendErrorMessage(datagram, ICMP_PARAMETER_PROBLEM, 0);

	Net result: all those modules got rid of their local sendErrorMessage()
	functions and errorOut gates; ICMP got rid of 4 input gates; connections
	on compound module level (IPProcessing) are more clear (only contain
	real data paths); operation is much faster (method call is a lot faster
	than assembling+sending cMessages). Code size keeps going down: e.g.
	PreRouting.cc now only contains 21 lines of code :)

	ErrorHandling module
	--------------------

	This modules was there at the top level of every host and router,
	its only task being receiving error packets from ICMP and printing them.
	Moved it down into IPProcessing, next to ICMP. Several NED files got
	simpler again (errorHandling submodule declarations, and corresponding
	connections and gates could be removed.)

	Thinking about removing ErrorHandling altogether.

	RoutingTableAccess
	------------------

	Killed RoutingTableAccess, LIBTableAccess etc base classes from everywhere.
	They were a bad idea in the first place, it should not be a base class.

	Introduced RoutingTableAccess, LIBTableAccess etc classes instead, which
	can be put into the module class as a private/protected data member:

	   protected:
	      RoutingTableAccess routingTableAccess;
	      LIBTableAccess libTableAccess;

	and used like this from the code:

	    RoutingTable *rt = routingTableAccess.get();
	    ...

	The ...Access classes just specialize a common ModuleAccess class so
	their code is just a few lines.

	RoutingTable module
	-------------------

	   * Routing file reader part turned into separate class
	     RoutingTableReader and moved into separate files.

	   * Several public methods renamed for clarity.

	   * Eliminated naked pointers (IPAddress* and char*), now it's
	     always IPAddress and opp_string.

	   * Changes to improve code readability.

	   * Oh yes: *routing table can be inspected via Tkenv*

	   * Added at least some ev<< output, and also counters (numDropped,
	     numForwarded, numMulticast, numLocalDeliver)

	UDPProcessing, UDPClient, UDP Server rewritten
	----------------------------------------------

	MPLS/RSVP-TE/LDP models
	-----------------------

	See mpls/ChangeLog.

	Documentation
	-------------

	Moving/reformatting comments so that Doxygen can use them.

	First round of changes: directory structure, documentation, adding MPLS
	(June-August 2003)
	=======================================================================

	Starting from IPSuite-20021124, the following changes were made:

	   * directory structure rearranged more-or-less along OSI layers,
	     with toplevel directories as follows: PHY, NetworkInterfaces,
	     Network, Transport, Applications, plus additional directories
	     Util, Nodes, Examples and Tests. Hopefully everything is now
	     where one would expect to find it.

	   * added MPLS/LDP/RESVP-TE models written by Xuan Thang Nguyen
	     at University of Technology, Sydney (see http://charlie.it.
	     uts.edu.au/~tkaphan/xtn/capstone/)

	   * added initial documentation to all NED files using existing
	     comments and documentation

	   * generated browsable HTML documentation from NED and C++ files

	   * generated new makefiles (using improved opp_makemake, included
	     in the distribution) for both Unix and MSVC. Configuration is
	     now taken from a file imported by all makefiles, so you need
	     to make changes only in one file.

	   * source code fixes to make everything compile with MSVC

	   * lots of minor fixes, e.g. to update code for OMNeT++ 2.3

	Starting point: IPSuite-20021124
	================================

	The starting point of the INET Framework development was IPSuite,
	developed at the University of Karlsruhe by Klaus Wehrle, Jochen Reber,
	Dirk Holzhausen, Volker Boehm, Verena Kahmann, Ulrich Kaage and others,
	during 2000-2001.

	If you are interested in the early history of the IPv4 code,
	change to the project root and type

	$ gitk -- Network/IPv4 INET/src/networklayer/ipv4
