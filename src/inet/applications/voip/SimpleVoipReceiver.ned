//
// Copyright (C) 2011 Adriano (University of Pisa)
// Copyright (C) 2012 OpenSim Ltd.
//
// SPDX-License-Identifier: LGPL-3.0-or-later
//

package inet.applications.voip;

import inet.applications.contract.IApp;

//
// Processes VoIP packet streams generated by ~SimpleVoipSender and calculates comprehensive
// quality metrics, with particular focus on the Mean Opinion Score (MOS). MOS is a standardized
// measure of perceived voice quality on a scale from 1 (poor) to 5 (excellent), calculated
// using the ITU-T G.107 E-Model. This model accounts for various impairments including packet
// loss, delay, and equipment factors to estimate user-perceived quality.
//
// Implements a playout buffer with configurable delay settings (fixed or adaptive) to handle
// network jitter. The module tracks multiple performance metrics including end-to-end delay,
// packet loss rate (network, playout buffer, and tail drop), and the resulting MOS values.
// All metrics are available as signals and statistics for analysis.
//
// The E-Model parameters (emodelIe, emodelBpl, emodelA, emodelRo) can be adjusted to model
// different codecs and network conditions, allowing for realistic voice quality assessment
// in various simulation scenarios.
//
// @see ~SimpleVoipSender, ~SimpleVoipPacket, ~UdpSocket
//
simple SimpleVoipReceiver like IApp
{
    parameters:
        int localPort;
        int emodelIe = default(5);        // Equipment impairment factor
        int emodelBpl = default(10);      // Packet-loss robustness factor
        int emodelA = default(5);         // Advantage factor
        double emodelRo = default(93.2);  // Basic signal-to-noise ratio

        double playoutDelay @unit(s) = default(0s);      // Initial delay for beginning playout after receiving the first packet
        bool adaptivePlayoutDelay = default(false);      // If true, adjust playoutDelay after each talkspurt
        int bufferSpace = default(20);      // Buffer size in packets
        double mosSpareTime @unit(s) = default(1s); // Spare time before calculating MOS (after calculated playout time of last packet)

        @signal[voipPacketDelay](type="simtime_t");      // When receive a frame
        @signal[voipPacketLossRate](type="double");      // At end of talkspurt
        @signal[voipPlayoutDelay](type="simtime_t");    // At end of talkspurt
        @signal[voipPlayoutLossRate](type="double");    // At end of talkspurt
        @signal[voipMosRate](type="double");          // At end of talkspurt
        @signal[voipTaildropLossRate](type="double");   // At end of talkspurt
        @statistic[endToEndDelay](title="VoIP Packet End-to-End Delay"; unit="s"; source="voipPacketDelay"; record=stats,vector);
        @statistic[packetLossRate](title="VoIP Packet Loss"; unit="ratio"; source="voipPacketLossRate"; record=stats,vector);
        @statistic[playoutDelay](title="VoIP Playout Delay"; unit="s"; source="voipPlayoutDelay"; record=stats,vector);
        @statistic[playoutLossRate](title="VoIP Playout Loss Rate"; unit="ratio"; source="voipPlayoutLossRate"; record=stats,vector);
        @statistic[mos](title="VoIP MOS"; unit="MOS"; source="voipMosRate"; record=stats,vector);
        @statistic[taildropLossRate](title="VoIP Tail Drop Loss Rate"; unit="ratio"; source="voipTaildropLossRate"; record=stats,vector);

        @display("i=block/source");
    gates:
        input socketIn @labels(UdpCommand/up);
        output socketOut @labels(UdpCommand/down);
}
