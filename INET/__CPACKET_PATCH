Index: src/applications/tcpapp/TCPSessionApp.cc
===================================================================
--- src/applications/tcpapp/TCPSessionApp.cc	(revision 2038)
+++ src/applications/tcpapp/TCPSessionApp.cc	(working copy)
@@ -54,7 +54,7 @@
     }
 }
 
-void TCPSessionApp::count(cMessage *msg)
+void TCPSessionApp::count(cPacket *msg)
 {
     if (msg->getKind()==TCP_I_DATA || msg->getKind()==TCP_I_URGENT_DATA)
     {
@@ -77,7 +77,7 @@
     cMessage *msg=NULL;
     while ((msg=receive())!=timeoutMsg)
     {
-        count(msg);
+//FIXME ??? PK() or if (isPacket) ?        count(msg);
         socket.processMessage(msg);
     }
     delete timeoutMsg;
@@ -138,7 +138,7 @@
     {
         waitUntil(tSend);
         EV << "sending " << sendBytes << " bytes\n";
-        cMessage *msg = new cMessage("data1");
+        cPacket *msg = new cPacket("data1");
         msg->setByteLength(sendBytes);
         socket.send(msg);
     }
@@ -146,7 +146,7 @@
     {
         waitUntil(i->tSend);
         EV << "sending " << i->numBytes << " bytes\n";
-        cMessage *msg = new cMessage("data1");
+        cPacket *msg = new cPacket("data1");
         msg->setByteLength(i->numBytes);
         socket.send(msg);
     }
@@ -164,7 +164,7 @@
     for (;;)
     {
         cMessage *msg = receive();
-        count(msg);
+        count(PK(msg));
         socket.processMessage(msg);
     }
 }
Index: src/applications/tcpapp/TCPSessionApp.h
===================================================================
--- src/applications/tcpapp/TCPSessionApp.h	(revision 2038)
+++ src/applications/tcpapp/TCPSessionApp.h	(working copy)
@@ -46,7 +46,7 @@
   protected:
     virtual void parseScript(const char *script);
     virtual void waitUntil(simtime_t t);
-    virtual void count(cMessage *msg);
+    virtual void count(cPacket *msg);
 
     virtual void activity();
     virtual void finish();
Index: src/applications/tcpapp/TelnetApp.h
===================================================================
--- src/applications/tcpapp/TelnetApp.h	(revision 2038)
+++ src/applications/tcpapp/TelnetApp.h	(working copy)
@@ -42,7 +42,7 @@
     virtual void socketEstablished(int connId, void *yourPtr);
 
     /** Redefined. */
-    virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
+    virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent);
 
     /** Redefined to start another session after a delay. */
     virtual void socketClosed(int connId, void *yourPtr);
Index: src/applications/tcpapp/TCPSinkApp.cc
===================================================================
--- src/applications/tcpapp/TCPSinkApp.cc	(revision 2038)
+++ src/applications/tcpapp/TCPSinkApp.cc	(working copy)
@@ -43,7 +43,7 @@
     }
     else if (msg->getKind()==TCP_I_DATA || msg->getKind()==TCP_I_URGENT_DATA)
     {
-        bytesRcvd += msg->getByteLength();
+        bytesRcvd += PK(msg)->getByteLength();
         delete msg;
 
         if (ev.isGUI())
Index: src/applications/tcpapp/TCPGenericSrvApp.cc
===================================================================
--- src/applications/tcpapp/TCPGenericSrvApp.cc	(revision 2038)
+++ src/applications/tcpapp/TCPGenericSrvApp.cc	(working copy)
@@ -1,3 +1,4 @@
+#if 0 //XXX
 //
 // Copyright 2004 Andras Varga
 //
@@ -143,4 +144,4 @@
     recordScalar("bytes sent", bytesSent);
     recordScalar("bytes rcvd", bytesRcvd);
 }
-
+#endif 0 //XXX
Index: src/applications/tcpapp/TCPSrvHostApp.h
===================================================================
--- src/applications/tcpapp/TCPSrvHostApp.h	(revision 2038)
+++ src/applications/tcpapp/TCPSrvHostApp.h	(working copy)
@@ -58,7 +58,7 @@
 
   protected:
     // internal: TCPSocket::CallbackInterface methods
-    virtual void socketDataArrived(int, void *, cMessage *msg, bool urgent) {dataArrived(msg,urgent);}
+    virtual void socketDataArrived(int, void *, cPacket *msg, bool urgent) {dataArrived(msg,urgent);}
     virtual void socketEstablished(int, void *)  {established();}
     virtual void socketPeerClosed(int, void *) {peerClosed();}
     virtual void socketClosed(int, void *) {closed();}
Index: src/applications/tcpapp/TCPEchoApp.h
===================================================================
--- src/applications/tcpapp/TCPEchoApp.h	(revision 2038)
+++ src/applications/tcpapp/TCPEchoApp.h	(working copy)
@@ -33,7 +33,7 @@
     long bytesSent;
 
   protected:
-    virtual void sendOrSchedule(cMessage *msg);
+    virtual void sendDown(cMessage *msg);
 
   protected:
     virtual void initialize();
Index: src/applications/tcpapp/TCPBasicClientApp.h
===================================================================
--- src/applications/tcpapp/TCPBasicClientApp.h	(revision 2038)
+++ src/applications/tcpapp/TCPBasicClientApp.h	(working copy)
@@ -46,7 +46,7 @@
     virtual void socketEstablished(int connId, void *yourPtr);
 
     /** Redefined. */
-    virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
+    virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent);
 
     /** Redefined to start another session after a delay. */
     virtual void socketClosed(int connId, void *yourPtr);
Index: src/applications/tcpapp/TelnetApp.cc
===================================================================
--- src/applications/tcpapp/TelnetApp.cc	(revision 2038)
+++ src/applications/tcpapp/TelnetApp.cc	(working copy)
@@ -95,7 +95,7 @@
     scheduleAt(simTime()+(simtime_t)par("thinkTime"), timeoutMsg);
 }
 
-void TelnetApp::socketDataArrived(int connId, void *ptr, cMessage *msg, bool urgent)
+void TelnetApp::socketDataArrived(int connId, void *ptr, cPacket *msg, bool urgent)
 {
     int len = msg->getByteLength();
     TCPGenericCliAppBase::socketDataArrived(connId, ptr, msg, urgent);
Index: src/applications/tcpapp/TCPGenericSrvThread.cc
===================================================================
--- src/applications/tcpapp/TCPGenericSrvThread.cc	(revision 2038)
+++ src/applications/tcpapp/TCPGenericSrvThread.cc	(working copy)
@@ -46,13 +46,13 @@
 
     if (requestedBytes==0)
     {
-        delete msg;
+        delete appmsg;
     }
     else
     {
-        msg->setByteLength(requestedBytes);
-        delete msg->removeControlInfo();
-        getSocket()->send(msg);
+        appmsg->setByteLength(requestedBytes);
+        delete appmsg->removeControlInfo();
+        getSocket()->send(appmsg);
     }
 
     if (doClose)
Index: src/applications/tcpapp/TCPGenericCliAppBase.cc
===================================================================
--- src/applications/tcpapp/TCPGenericCliAppBase.cc	(revision 2038)
+++ src/applications/tcpapp/TCPGenericCliAppBase.cc	(working copy)
@@ -98,7 +98,7 @@
     setStatusString("connected");
 }
 
-void TCPGenericCliAppBase::socketDataArrived(int, void *, cMessage *msg, bool)
+void TCPGenericCliAppBase::socketDataArrived(int, void *, cPacket *msg, bool)
 {
     // *redefine* to perform or schedule next sending
     packetsRcvd++;
Index: src/applications/tcpapp/TCPGenericCliAppBase.h
===================================================================
--- src/applications/tcpapp/TCPGenericCliAppBase.h	(revision 2038)
+++ src/applications/tcpapp/TCPGenericCliAppBase.h	(working copy)
@@ -85,7 +85,7 @@
      * Does nothing but update statistics/status. Redefine to perform or schedule next sending.
      * Beware: this funcion deletes the incoming message, which might not be what you want.
      */
-    virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
+    virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent);
 
     /** Since remote TCP closed, invokes close(). Redefine if you want to do something else. */
     virtual void socketPeerClosed(int connId, void *yourPtr);
Index: src/applications/tcpapp/GenericAppMsg.msg
===================================================================
--- src/applications/tcpapp/GenericAppMsg.msg	(revision 2038)
+++ src/applications/tcpapp/GenericAppMsg.msg	(working copy)
@@ -34,7 +34,7 @@
 //
 // @see TCPGenericSrvApp, TCPGenericCliAppBase (C++ only)
 //
-message GenericAppMsg
+packet GenericAppMsg
 {
     int expectedReplyLength; // in bytes
     double replyDelay;       // reply after this many seconds
Index: src/applications/tcpapp/TCPEchoApp.cc
===================================================================
--- src/applications/tcpapp/TCPEchoApp.cc	(revision 2038)
+++ src/applications/tcpapp/TCPEchoApp.cc	(working copy)
@@ -36,54 +36,55 @@
     socket.listen();
 }
 
-void TCPEchoApp::sendOrSchedule(cMessage *msg)
+void TCPEchoApp::sendDown(cMessage *msg)
 {
-    if (delay==0)
-    {
-        bytesSent += msg->getByteLength();
-        send(msg, "tcpOut");
-    }
-    else
-    {
-        scheduleAt(simTime()+delay, msg);
-    }
+    if (msg->isPacket())
+        bytesSent += ((cPacket *)msg)->getByteLength();
+    send(msg, "tcpOut");
 }
 
 void TCPEchoApp::handleMessage(cMessage *msg)
 {
     if (msg->isSelfMessage())
     {
-        bytesSent += msg->getByteLength();
-        send(msg, "tcpOut");
+        sendDown(msg);
     }
     else if (msg->getKind()==TCP_I_PEER_CLOSED)
     {
         // we'll close too
         msg->setKind(TCP_C_CLOSE);
-        sendOrSchedule(msg);
+        if (delay==0)
+            sendDown(msg);
+        else
+            scheduleAt(simTime()+delay, msg); // send after a delay
     }
     else if (msg->getKind()==TCP_I_DATA || msg->getKind()==TCP_I_URGENT_DATA)
     {
-        bytesRcvd += msg->getByteLength();
+        cPacket *pkt = check_and_cast<cPacket *>(msg);
+        bytesRcvd += pkt->getByteLength();
+
         if (echoFactor==0)
         {
-            delete msg;
+            delete pkt;
         }
         else
         {
             // reverse direction, modify length, and send it back
-            msg->setKind(TCP_C_SEND);
-            TCPCommand *ind = check_and_cast<TCPCommand *>(msg->removeControlInfo());
+            pkt->setKind(TCP_C_SEND);
+            TCPCommand *ind = check_and_cast<TCPCommand *>(pkt->removeControlInfo());
             TCPSendCommand *cmd = new TCPSendCommand();
             cmd->setConnId(ind->getConnId());
-            msg->setControlInfo(cmd);
+            pkt->setControlInfo(cmd);
             delete ind;
 
-            long byteLen = msg->getByteLength()*echoFactor;
+            long byteLen = pkt->getByteLength()*echoFactor;
             if (byteLen<1) byteLen=1;
-            msg->setByteLength(byteLen);
+            pkt->setByteLength(byteLen);
 
-            sendOrSchedule(msg);
+            if (delay==0)
+                sendDown(pkt);
+            else
+                scheduleAt(simTime()+delay, pkt); // send after a delay
         }
     }
     else
Index: src/applications/tcpapp/TCPBasicClientApp.cc
===================================================================
--- src/applications/tcpapp/TCPBasicClientApp.cc	(revision 2038)
+++ src/applications/tcpapp/TCPBasicClientApp.cc	(working copy)
@@ -96,7 +96,7 @@
     numRequestsToSend--;
 }
 
-void TCPBasicClientApp::socketDataArrived(int connId, void *ptr, cMessage *msg, bool urgent)
+void TCPBasicClientApp::socketDataArrived(int connId, void *ptr, cPacket *msg, bool urgent)
 {
     TCPGenericCliAppBase::socketDataArrived(connId, ptr, msg, urgent);
 
Index: src/applications/udpapp/UDPBasicApp.cc
===================================================================
--- src/applications/udpapp/UDPBasicApp.cc	(revision 2038)
+++ src/applications/udpapp/UDPBasicApp.cc	(working copy)
@@ -67,19 +67,19 @@
 }
 
 
-cMessage *UDPBasicApp::createPacket()
+cPacket *UDPBasicApp::createPacket()
 {
     char msgName[32];
     sprintf(msgName,"UDPBasicAppData-%d", counter++);
 
-    cMessage *payload = new cMessage(msgName);
+    cPacket *payload = new cPacket(msgName);
     payload->setByteLength(msgByteLength);
     return payload;
 }
 
 void UDPBasicApp::sendPacket()
 {
-    cMessage *payload = createPacket();
+    cPacket *payload = createPacket();
     IPvXAddress destAddr = chooseDestAddr();
     sendToUDP(payload, localPort, destAddr, destPort);
 
@@ -97,7 +97,7 @@
     else
     {
         // process incoming packet
-        processPacket(msg);
+        processPacket(PK(msg));
     }
 
     if (ev.isGUI())
@@ -109,7 +109,7 @@
 }
 
 
-void UDPBasicApp::processPacket(cMessage *msg)
+void UDPBasicApp::processPacket(cPacket *msg)
 {
     EV << "Received packet: ";
     printPacket(msg);
Index: src/applications/udpapp/UDPBasicApp.h
===================================================================
--- src/applications/udpapp/UDPBasicApp.h	(revision 2038)
+++ src/applications/udpapp/UDPBasicApp.h	(working copy)
@@ -44,9 +44,9 @@
 
     // chooses random destination address
     virtual IPvXAddress chooseDestAddr();
-    virtual cMessage *createPacket();
+    virtual cPacket *createPacket();
     virtual void sendPacket();
-    virtual void processPacket(cMessage *msg);
+    virtual void processPacket(cPacket *msg);
 
   protected:
     virtual int numInitStages() const {return 4;}
Index: src/applications/udpapp/UDPEchoAppMsg.msg
===================================================================
--- src/applications/udpapp/UDPEchoAppMsg.msg	(revision 2038)
+++ src/applications/udpapp/UDPEchoAppMsg.msg	(working copy)
@@ -20,7 +20,7 @@
 //
 // Message class used by UDPEchoApp.
 //
-message UDPEchoAppMsg
+packet UDPEchoAppMsg
 {
     bool isRequest = true;
 }
Index: src/applications/udpapp/UDPSink.cc
===================================================================
--- src/applications/udpapp/UDPSink.cc	(revision 2038)
+++ src/applications/udpapp/UDPSink.cc	(working copy)
@@ -38,7 +38,7 @@
 
 void UDPSink::handleMessage(cMessage *msg)
 {
-    processPacket(msg);
+    processPacket(PK(msg));
 
     if (ev.isGUI())
     {
@@ -49,7 +49,7 @@
 
 }
 
-void UDPSink::processPacket(cMessage *msg)
+void UDPSink::processPacket(cPacket *msg)
 {
     EV << "Received packet: ";
     printPacket(msg);
Index: src/applications/udpapp/UDPSink.h
===================================================================
--- src/applications/udpapp/UDPSink.h	(revision 2038)
+++ src/applications/udpapp/UDPSink.h	(working copy)
@@ -34,7 +34,7 @@
     int numReceived;
 
   protected:
-    virtual void processPacket(cMessage *msg);
+    virtual void processPacket(cPacket *msg);
 
   protected:
     virtual void initialize();
Index: src/applications/udpapp/UDPVideoStreamCli.cc
===================================================================
--- src/applications/udpapp/UDPVideoStreamCli.cc	(revision 2038)
+++ src/applications/udpapp/UDPVideoStreamCli.cc	(working copy)
@@ -50,7 +50,7 @@
     }
     else
     {
-        receiveStream(msg);
+        receiveStream(PK(msg));
     }
 }
 
@@ -70,11 +70,11 @@
 
     bindToPort(localPort);
 
-    cMessage *msg = new cMessage("VideoStrmReq");
+    cPacket *msg = new cPacket("VideoStrmReq");
     sendToUDP(msg, localPort, svrAddr, svrPort);
 }
 
-void UDPVideoStreamCli::receiveStream(cMessage* msg)
+void UDPVideoStreamCli::receiveStream(cPacket *msg)
 {
     EV << "Video stream packet:\n";
     printPacket(msg);
Index: src/applications/udpapp/UDPAppBase.cc
===================================================================
--- src/applications/udpapp/UDPAppBase.cc	(revision 2038)
+++ src/applications/udpapp/UDPAppBase.cc	(working copy)
@@ -36,7 +36,7 @@
     send(msg, "udpOut");
 }
 
-void UDPAppBase::sendToUDP(cMessage *msg, int srcPort, const IPvXAddress& destAddr, int destPort)
+void UDPAppBase::sendToUDP(cPacket *msg, int srcPort, const IPvXAddress& destAddr, int destPort)
 {
     // send message to UDP, with the appropriate control info attached
     msg->setKind(UDP_C_DATA);
@@ -53,7 +53,7 @@
     send(msg, "udpOut");
 }
 
-void UDPAppBase::printPacket(cMessage *msg)
+void UDPAppBase::printPacket(cPacket *msg)
 {
     UDPControlInfo *ctrl = check_and_cast<UDPControlInfo *>(msg->getControlInfo());
 
Index: src/applications/udpapp/UDPVideoStreamCli.h
===================================================================
--- src/applications/udpapp/UDPVideoStreamCli.h	(revision 2038)
+++ src/applications/udpapp/UDPVideoStreamCli.h	(working copy)
@@ -44,12 +44,12 @@
     //@{
     virtual void initialize();
     virtual void finish();
-    virtual void handleMessage(cMessage* msg);
+    virtual void handleMessage(cMessage *msg);
     //@}
 
   protected:
     virtual void requestStream();
-    virtual void receiveStream(cMessage* msg);
+    virtual void receiveStream(cPacket *msg);
 };
 
 
Index: src/applications/udpapp/UDPAppBase.h
===================================================================
--- src/applications/udpapp/UDPAppBase.h	(revision 2038)
+++ src/applications/udpapp/UDPAppBase.h	(working copy)
@@ -39,13 +39,13 @@
     /**
      * Sends a packet over UDP
      */
-    virtual void sendToUDP(cMessage *msg, int srcPort, const IPvXAddress& destAddr, int destPort);
+    virtual void sendToUDP(cPacket *msg, int srcPort, const IPvXAddress& destAddr, int destPort);
 
     /**
      * Prints a brief about packets having an attached UDPControlInfo
      * (i.e. those which just arrived from UDP, or about to be send to UDP).
      */
-    virtual void printPacket(cMessage *msg);
+    virtual void printPacket(cPacket *msg);
 };
 
 
Index: src/applications/udpapp/UDPVideoStreamSvr.cc
===================================================================
--- src/applications/udpapp/UDPVideoStreamSvr.cc	(revision 2038)
+++ src/applications/udpapp/UDPVideoStreamSvr.cc	(working copy)
@@ -108,7 +108,7 @@
     VideoStreamData *d = (VideoStreamData *) timer->getContextPointer();
 
     // generate and send a packet
-    cMessage *pkt = new cMessage("VideoStrmPk");
+    cPacket *pkt = new cPacket("VideoStrmPk");
     long pktLen = packetLen->longValue();
     if (pktLen > d->bytesLeft)
         pktLen = d->bytesLeft;
Index: src/applications/udpapp/UDPEchoApp.cc
===================================================================
--- src/applications/udpapp/UDPEchoApp.cc	(revision 2038)
+++ src/applications/udpapp/UDPEchoApp.cc	(working copy)
@@ -39,18 +39,18 @@
 {
 }
 
-cMessage *UDPEchoApp::createPacket()
+cPacket *UDPEchoApp::createPacket()
 {
     char msgName[32];
     sprintf(msgName,"UDPEcho-%d", counter++);
 
-    cMessage *message = new UDPEchoAppMsg(msgName);
+    UDPEchoAppMsg *message = new UDPEchoAppMsg(msgName);
     message->setByteLength(msgByteLength);
 
     return message;
 }
 
-void UDPEchoApp::processPacket(cMessage *msg)
+void UDPEchoApp::processPacket(cPacket *msg)
 {
     UDPEchoAppMsg *packet = check_and_cast<UDPEchoAppMsg *>(msg);
 
Index: src/applications/udpapp/UDPEchoApp.h
===================================================================
--- src/applications/udpapp/UDPEchoApp.h	(revision 2038)
+++ src/applications/udpapp/UDPEchoApp.h	(working copy)
@@ -31,8 +31,8 @@
 class UDPEchoApp : public UDPBasicApp
 {
   protected:
-    virtual cMessage *createPacket();
-    virtual void processPacket(cMessage *msg);
+    virtual cPacket *createPacket();
+    virtual void processPacket(cPacket *msg);
 
   protected:
     virtual void initialize(int stage);
Index: src/applications/generic/IPTrafGen.cc
===================================================================
--- src/applications/generic/IPTrafGen.cc	(revision 2038)
+++ src/applications/generic/IPTrafGen.cc	(working copy)
@@ -36,7 +36,7 @@
 
 void IPTrafSink::handleMessage(cMessage *msg)
 {
-    processPacket(msg);
+    processPacket(check_and_cast<cPacket *>(msg));
 
     if (ev.isGUI())
     {
@@ -47,7 +47,7 @@
 
 }
 
-void IPTrafSink::printPacket(cMessage *msg)
+void IPTrafSink::printPacket(cPacket *msg)
 {
     IPvXAddress src, dest;
     int protocol = -1;
@@ -72,7 +72,7 @@
         ev  << "src: " << src << "  dest: " << dest << "  protocol=" << protocol << "\n";
 }
 
-void IPTrafSink::processPacket(cMessage *msg)
+void IPTrafSink::processPacket(cPacket *msg)
 {
     EV << "Received packet: ";
     printPacket(msg);
@@ -133,7 +133,7 @@
     char msgName[32];
     sprintf(msgName,"appData-%d", counter++);
 
-    cMessage *payload = new cMessage(msgName);
+    cPacket *payload = new cPacket(msgName);
     payload->setByteLength(msgByteLength);
 
     IPvXAddress destAddr = chooseDestAddr();
@@ -179,7 +179,7 @@
     else
     {
         // process incoming packet
-        processPacket(msg);
+        processPacket(PK(msg));
     }
 
     if (ev.isGUI())
Index: src/applications/generic/IPTrafGen.h
===================================================================
--- src/applications/generic/IPTrafGen.h	(revision 2038)
+++ src/applications/generic/IPTrafGen.h	(working copy)
@@ -35,8 +35,8 @@
   protected:
     int numReceived;
 
-    virtual void printPacket(cMessage *msg);
-    virtual void processPacket(cMessage *msg);
+    virtual void printPacket(cPacket *msg);
+    virtual void processPacket(cPacket *msg);
 
   protected:
     virtual void initialize();
Index: src/applications/ethernet/EtherApp.msg
===================================================================
--- src/applications/ethernet/EtherApp.msg	(revision 2038)
+++ src/applications/ethernet/EtherApp.msg	(working copy)
@@ -29,7 +29,7 @@
 // sent back as response; if this value is greater than ~1400, the reply
 // will consist of several Ethernet frames. See also EtherAppResp.
 //
-message EtherAppReq
+packet EtherAppReq
 {
     long requestId;
     long responseBytes;
@@ -38,7 +38,7 @@
 //
 // Packet sent back by EtherAppSrv in response to an EtherAppReq.
 //
-message EtherAppResp
+packet EtherAppResp
 {
     int requestId;
     int numFrames;
Index: src/applications/pingapp/PingPayload.msg
===================================================================
--- src/applications/pingapp/PingPayload.msg	(revision 2038)
+++ src/applications/pingapp/PingPayload.msg	(working copy)
@@ -26,7 +26,7 @@
 //
 // Represents payload in an ICMP/ICMPv6 Echo Request/Reply.
 //
-message PingPayload
+packet PingPayload
 {
     long originatorId; // sender module id
     long seqNo; // sequence number
Index: src/networklayer/ldp/LDP.cc
===================================================================
--- src/networklayer/ldp/LDP.cc	(revision 2038)
+++ src/networklayer/ldp/LDP.cc	(working copy)
@@ -587,7 +587,7 @@
     // FIXME start LDP session setup (if we're on the active side?)
 }
 
-void LDP::socketDataArrived(int, void *yourPtr, cMessage *msg, bool)
+void LDP::socketDataArrived(int, void *yourPtr, cPacket *msg, bool)
 {
     peer_info& peer = myPeers[(long)yourPtr];
     EV << "Message arrived over TCP from peer " << peer.peerIP << "\n";
Index: src/networklayer/ldp/LDP.h
===================================================================
--- src/networklayer/ldp/LDP.h	(revision 2038)
+++ src/networklayer/ldp/LDP.h	(working copy)
@@ -198,7 +198,7 @@
     /** @name TCPSocket::CallbackInterface callback methods */
     //@{
     virtual void socketEstablished(int connId, void *yourPtr);
-    virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
+    virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent);
     virtual void socketPeerClosed(int connId, void *yourPtr);
     virtual void socketClosed(int connId, void *yourPtr);
     virtual void socketFailure(int connId, void *yourPtr, int code);
Index: src/networklayer/ldp/LDPPacket.msg
===================================================================
--- src/networklayer/ldp/LDPPacket.msg	(revision 2038)
+++ src/networklayer/ldp/LDPPacket.msg	(working copy)
@@ -59,7 +59,7 @@
 //
 // Base class for LDP packets
 //
-message LDPPacket
+packet LDPPacket
 {
     int type;
     IPAddress senderAddress;
@@ -70,7 +70,7 @@
 //
 // LDP Label Mapping Message
 //
-message LDPLabelMapping extends LDPPacket
+packet LDPLabelMapping extends LDPPacket
 {
     FEC_TLV fec;
     int label;
@@ -79,7 +79,7 @@
 //
 // LDP Label Request Message
 //
-message LDPLabelRequest extends LDPPacket
+packet LDPLabelRequest extends LDPPacket
 {
     FEC_TLV fec;
 }
@@ -88,7 +88,7 @@
 //
 // LDP Hello Message
 //
-message LDPHello extends LDPPacket
+packet LDPHello extends LDPPacket
 {
     double holdTime;
     bool tbit;
@@ -98,7 +98,7 @@
 //
 // LDP notification message
 //
-message LDPNotify extends LDPPacket
+packet LDPNotify extends LDPPacket
 {
     int status;
     FEC_TLV fec;
@@ -108,7 +108,7 @@
 // LDP Ini Message
 //
 //# FIXME currently unused
-message LDPIni extends LDPPacket
+packet LDPIni extends LDPPacket
 {
     double keepAliveTime;
     bool abit;
@@ -121,7 +121,7 @@
 // LDP Address Message
 //
 //# FIXME currently unused
-message LDPAddress extends LDPPacket
+packet LDPAddress extends LDPPacket
 {
     bool isWithdraw;
     string family;
Index: src/networklayer/ospfv2/OSPFPacket.msg
===================================================================
--- src/networklayer/ospfv2/OSPFPacket.msg	(revision 2038)
+++ src/networklayer/ospfv2/OSPFPacket.msg	(working copy)
@@ -48,7 +48,7 @@
 //
 // Represents an OSPF packet header
 //
-message OSPFPacket
+packet OSPFPacket
 {
     char version = 2;
     char type enum(OSPFPacketType) = HelloPacket;
@@ -65,7 +65,7 @@
 //
 // Represents an OSPF Hello packet
 //
-message OSPFHelloPacket extends OSPFPacket
+packet OSPFHelloPacket extends OSPFPacket
 {
     IPAddress networkMask;
 
@@ -220,7 +220,7 @@
 //
 // Represents an OSPF Database Description packet
 //
-message OSPFDatabaseDescriptionPacket extends OSPFPacket
+packet OSPFDatabaseDescriptionPacket extends OSPFPacket
 {
     unsigned short interfaceMTU;
     OSPFOptions options;
@@ -239,7 +239,7 @@
 //
 // Represents an OSPF Link State Request packet
 //
-message OSPFLinkStateRequestPacket extends OSPFPacket
+packet OSPFLinkStateRequestPacket extends OSPFPacket
 {
     LSARequest requests[];
 }
@@ -247,7 +247,7 @@
 //
 // Represents an OSPF Link State Update packet
 //
-message OSPFLinkStateUpdatePacket extends OSPFPacket
+packet OSPFLinkStateUpdatePacket extends OSPFPacket
 {
     unsigned long numberOfLSAs;
     OSPFRouterLSA routerLSAs[];
@@ -259,7 +259,7 @@
 //
 // Represents an OSPF Link State Acknowledgement packet
 //
-message OSPFLinkStateAcknowledgementPacket extends OSPFPacket
+packet OSPFLinkStateAcknowledgementPacket extends OSPFPacket
 {
     OSPFLSAHeader lsaHeaders[];
 }
Index: src/networklayer/ospfv2/OSPFTimer.msg
===================================================================
--- src/networklayer/ospfv2/OSPFTimer.msg	(revision 2038)
+++ src/networklayer/ospfv2/OSPFTimer.msg	(working copy)
@@ -32,7 +32,7 @@
 //
 // Represents an OSPF Timer
 //
-message OSPFTimer extends cMessage
+packet OSPFTimer extends cMessage
 {
     char timerKind enum(OSPFTimerType) = InterfaceHelloTimer;
 }
Index: src/networklayer/arp/ARPPacket.msg
===================================================================
--- src/networklayer/arp/ARPPacket.msg	(revision 2038)
+++ src/networklayer/arp/ARPPacket.msg	(working copy)
@@ -54,7 +54,7 @@
 //   - hardware address length (6)
 //   - protocol address length (4)
 //
-message ARPPacket
+packet ARPPacket
 {
     int opcode enum(ARPOpcode);
     MACAddress srcMACAddress;
Index: src/networklayer/ipv4/ICMPMessage.msg
===================================================================
--- src/networklayer/ipv4/ICMPMessage.msg	(revision 2038)
+++ src/networklayer/ipv4/ICMPMessage.msg	(working copy)
@@ -78,7 +78,7 @@
 //
 // ICMP message class
 //
-message ICMPMessage
+packet ICMPMessage
 {
     int type enum(ICMPType);
     int code;
Index: src/networklayer/ipv4/IP.cc
===================================================================
--- src/networklayer/ipv4/IP.cc	(revision 2038)
+++ src/networklayer/ipv4/IP.cc	(working copy)
@@ -73,7 +73,7 @@
 {
     if (msg->getArrivalGate()->isName("transportIn"))
     {
-        handleMessageFromHL(msg);
+        handleMessageFromHL(PK(msg));
     }
     else if (dynamic_cast<ARPPacket *>(msg))
     {
@@ -90,7 +90,7 @@
         updateDisplayString();
 }
 
-InterfaceEntry *IP::getSourceInterfaceFrom(cMessage *msg)
+InterfaceEntry *IP::getSourceInterfaceFrom(cPacket *msg)
 {
     cGate *g = msg->getArrivalGate();
     return g ? ift->getInterfaceByNetworkLayerGateIndex(g->getIndex()) : NULL;
@@ -171,7 +171,7 @@
     }
 }
 
-void IP::handleMessageFromHL(cMessage *msg)
+void IP::handleMessageFromHL(cPacket *msg)
 {
     // if no interface exists, do not send datagram
     if (ift->getNumInterfaces() == 0)
@@ -388,7 +388,7 @@
 
     // decapsulate and send on appropriate output gate
     int protocol = datagram->getTransportProtocol();
-    cMessage *packet = decapsulateIP(datagram);
+    cPacket *packet = decapsulateIP(datagram);
 
     if (protocol==IP_PROT_ICMP)
     {
@@ -407,11 +407,11 @@
     }
 }
 
-cMessage *IP::decapsulateIP(IPDatagram *datagram)
+cPacket *IP::decapsulateIP(IPDatagram *datagram)
 {
     // decapsulate transport packet
     InterfaceEntry *fromIE = getSourceInterfaceFrom(datagram);
-    cMessage *packet = datagram->decapsulate();
+    cPacket *packet = datagram->decapsulate();
 
     // create and fill in control info
     IPControlInfo *controlInfo = new IPControlInfo();
@@ -493,7 +493,7 @@
 }
 
 
-IPDatagram *IP::encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE)
+IPDatagram *IP::encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE)
 {
     IPControlInfo *controlInfo = check_and_cast<IPControlInfo*>(transportPacket->removeControlInfo());
     IPDatagram *datagram = encapsulate(transportPacket, destIE, controlInfo);
@@ -501,7 +501,7 @@
     return datagram;
 }
 
-IPDatagram *IP::encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE, IPControlInfo *controlInfo)
+IPDatagram *IP::encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE, IPControlInfo *controlInfo)
 {
     IPDatagram *datagram = createIPDatagram(transportPacket->getName());
     datagram->setByteLength(IP_HEADER_BYTES);
Index: src/networklayer/ipv4/IP.h
===================================================================
--- src/networklayer/ipv4/IP.h	(revision 2038)
+++ src/networklayer/ipv4/IP.h	(working copy)
@@ -68,7 +68,7 @@
 
   protected:
     // utility: look up interface from getArrivalGate()
-    virtual InterfaceEntry *getSourceInterfaceFrom(cMessage *msg);
+    virtual InterfaceEntry *getSourceInterfaceFrom(cPacket *msg);
 
     // utility: show current statistics above the icon
     virtual void updateDisplayString();
@@ -77,14 +77,14 @@
      * Encapsulate packet coming from higher layers into IPDatagram, using
      * the control info attached to the packet.
      */
-    virtual IPDatagram *encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE);
+    virtual IPDatagram *encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE);
 
     /**
      * Encapsulate packet coming from higher layers into IPDatagram, using
      * the given control info. Override if you subclassed controlInfo and/or
      * want to add options etc to the datagram.
      */
-    virtual IPDatagram *encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE, IPControlInfo *controlInfo);
+    virtual IPDatagram *encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE, IPControlInfo *controlInfo);
 
     /**
      * Creates a blank IP datagram. Override when subclassing IPDatagram is needed
@@ -101,7 +101,7 @@
      * Handle messages (typically packets to be send in IP) from transport or ICMP.
      * Invokes encapsulate(), then routePacket().
      */
-    virtual void handleMessageFromHL(cMessage *msg);
+    virtual void handleMessageFromHL(cPacket *msg);
 
     /**
      * Handle incoming ARP packets by sending them over "queueOut" to ARP.
@@ -135,7 +135,7 @@
     /**
      * Decapsulate and return encapsulated packet after attaching IPControlInfo.
      */
-    virtual cMessage *decapsulateIP(IPDatagram *datagram);
+    virtual cPacket *decapsulateIP(IPDatagram *datagram);
 
     /**
      * Fragment packet if needed, then send it to the selected interface using
Index: src/networklayer/ipv4/IPDatagram.msg
===================================================================
--- src/networklayer/ipv4/IPDatagram.msg	(revision 2038)
+++ src/networklayer/ipv4/IPDatagram.msg	(working copy)
@@ -126,7 +126,7 @@
 //
 // Only only one of the option fields can exist at a time.
 //
-message IPDatagram
+packet IPDatagram
 {
     short version = 4;
     short headerLength = IP_HEADER_BYTES;
Index: src/networklayer/ipv4/ControlManetRouting.msg
===================================================================
--- src/networklayer/ipv4/ControlManetRouting.msg	(revision 2038)
+++ src/networklayer/ipv4/ControlManetRouting.msg	(working copy)
@@ -35,7 +35,7 @@
 //
 // ICMP message class
 //
-message ControlManetRouting
+packet ControlManetRouting
 {
     IPAddress srcAddress;
     IPAddress destAddress;
Index: src/networklayer/ipv4/ICMP.cc
===================================================================
--- src/networklayer/ipv4/ICMP.cc	(revision 2038)
+++ src/networklayer/ipv4/ICMP.cc	(working copy)
@@ -43,7 +43,7 @@
     // request from application
     if (!strcmp(arrivalGate->getName(), "pingIn"))
     {
-        sendEchoRequest(msg);
+        sendEchoRequest(PK(msg));
         return;
     }
 }
@@ -112,7 +112,7 @@
     }
 }
 
-void ICMP::sendErrorMessage(cMessage *transportPacket, IPControlInfo *ctrl, ICMPType type, ICMPCode code)
+void ICMP::sendErrorMessage(cPacket *transportPacket, IPControlInfo *ctrl, ICMPType type, ICMPCode code)
 {
     Enter_Method("sendErrorMessage(transportPacket, ctrl, type=%d, code=%d)", type, code);
 
@@ -182,13 +182,13 @@
 void ICMP::processEchoReply(ICMPMessage *reply)
 {
     IPControlInfo *ctrl = check_and_cast<IPControlInfo*>(reply->removeControlInfo());
-    cMessage *payload = reply->decapsulate();
+    cPacket *payload = reply->decapsulate();
     payload->setControlInfo(ctrl);
     delete reply;
     send(payload, "pingOut");
 }
 
-void ICMP::sendEchoRequest(cMessage *msg)
+void ICMP::sendEchoRequest(cPacket *msg)
 {
     IPControlInfo *ctrl = check_and_cast<IPControlInfo*>(msg->removeControlInfo());
     ctrl->setProtocol(IP_PROT_ICMP);
Index: src/networklayer/ipv4/ICMP.h
===================================================================
--- src/networklayer/ipv4/ICMP.h	(revision 2038)
+++ src/networklayer/ipv4/ICMP.h	(working copy)
@@ -42,7 +42,7 @@
     virtual void errorOut(ICMPMessage *);
     virtual void processEchoRequest (ICMPMessage *);
     virtual void processEchoReply (ICMPMessage *);
-    virtual void sendEchoRequest(cMessage *);
+    virtual void sendEchoRequest(cPacket *);
     virtual void sendToIP(ICMPMessage *, const IPAddress& dest);
     virtual void sendToIP(ICMPMessage *msg);
 
@@ -60,7 +60,7 @@
      * so this function will wrap back the transport packet into the IP datagram
      * based on its IPControlInfo.
      */
-    virtual void sendErrorMessage(cMessage *transportPacket, IPControlInfo *ctrl, ICMPType type, ICMPCode code);
+    virtual void sendErrorMessage(cPacket *transportPacket, IPControlInfo *ctrl, ICMPType type, ICMPCode code);
 
   protected:
     virtual void handleMessage(cMessage *msg);
Index: src/networklayer/rsvp_te/Utils.cc
===================================================================
--- src/networklayer/rsvp_te/Utils.cc	(revision 2038)
+++ src/networklayer/rsvp_te/Utils.cc	(working copy)
@@ -62,7 +62,7 @@
         dest.push_back(src[i]);
 }
 
-cModule *getPayloadOwner(cMessage *msg)
+cModule *getPayloadOwner(cPacket *msg)
 {
     while(msg->getEncapsulatedMsg())
         msg = msg->getEncapsulatedMsg();
Index: src/networklayer/rsvp_te/RSVPResvMsg.msg
===================================================================
--- src/networklayer/rsvp_te/RSVPResvMsg.msg	(revision 2038)
+++ src/networklayer/rsvp_te/RSVPResvMsg.msg	(working copy)
@@ -33,7 +33,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPResvMsg extends RSVPPacket
+packet RSVPResvMsg extends RSVPPacket
 {
     @customize(true);
     RsvpHopObj_t hop;
@@ -44,7 +44,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPResvTear extends RSVPPacket
+packet RSVPResvTear extends RSVPPacket
 {
     @customize(true);
     RsvpHopObj_t hop;
@@ -55,7 +55,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPResvError extends RSVPPacket
+packet RSVPResvError extends RSVPPacket
 {
     @customize(true);
     RsvpHopObj_t hop;
Index: src/networklayer/rsvp_te/Utils.h
===================================================================
--- src/networklayer/rsvp_te/Utils.h	(revision 2038)
+++ src/networklayer/rsvp_te/Utils.h	(working copy)
@@ -45,9 +45,9 @@
 int find(const EroVector& ERO, IPAddress node);
 
 /**
- * TODO documentation
+ * XXX function appears to be unused
  */
-cModule *getPayloadOwner(cMessage *msg);
+cModule *getPayloadOwner(cPacket *msg);
 
 //void prepend(EroVector& dest, const EroVector& src, bool reverse);
 
Index: src/networklayer/rsvp_te/RSVPPathMsg.msg
===================================================================
--- src/networklayer/rsvp_te/RSVPPathMsg.msg	(revision 2038)
+++ src/networklayer/rsvp_te/RSVPPathMsg.msg	(working copy)
@@ -39,7 +39,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPPathMsg extends RSVPPacket
+packet RSVPPathMsg extends RSVPPacket
 {
     @customize(true);
     RsvpHopObj_t hop;
@@ -54,7 +54,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPPathTear extends RSVPPacket
+packet RSVPPathTear extends RSVPPacket
 {
     @customize(true);
     RsvpHopObj_t hop;
@@ -67,7 +67,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPPathError extends RSVPPacket
+packet RSVPPathError extends RSVPPacket
 {
     @customize(true);
     IPAddress errorNode;
Index: src/networklayer/rsvp_te/RSVPHello.msg
===================================================================
--- src/networklayer/rsvp_te/RSVPHello.msg	(revision 2038)
+++ src/networklayer/rsvp_te/RSVPHello.msg	(working copy)
@@ -25,7 +25,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPHelloMsg extends RSVPMessage
+packet RSVPHelloMsg extends RSVPMessage
 {
     @customize(true);
     bool request;
Index: src/networklayer/rsvp_te/RSVPPacket.msg
===================================================================
--- src/networklayer/rsvp_te/RSVPPacket.msg	(revision 2038)
+++ src/networklayer/rsvp_te/RSVPPacket.msg	(working copy)
@@ -52,7 +52,7 @@
 //
 // \RSVP message common part
 //
-message RSVPMessage
+packet RSVPMessage
 {
     int rsvpKind;
 }
@@ -60,7 +60,7 @@
 //
 // FIXME missing documentation
 //
-message RSVPPacket extends RSVPMessage
+packet RSVPPacket extends RSVPMessage
 {
     @customize(true);
     SessionObj_t session;
Index: src/networklayer/icmpv6/ICMPv6.cc
===================================================================
--- src/networklayer/icmpv6/ICMPv6.cc	(revision 2038)
+++ src/networklayer/icmpv6/ICMPv6.cc	(working copy)
@@ -43,7 +43,7 @@
     // request from application
     if (msg->getArrivalGate()->isName("pingIn"))
     {
-        sendEchoRequest(msg);
+        sendEchoRequest(PK(msg));
         return;
     }
 }
@@ -111,13 +111,13 @@
 void ICMPv6::processEchoReply(ICMPv6EchoReplyMsg *reply)
 {
     IPv6ControlInfo *ctrl = check_and_cast<IPv6ControlInfo*>(reply->removeControlInfo());
-    cMessage *payload = reply->decapsulate();
+    cPacket *payload = reply->decapsulate();
     payload->setControlInfo(ctrl);
     delete reply;
     send(payload, "pingOut");
 }
 
-void ICMPv6::sendEchoRequest(cMessage *msg)
+void ICMPv6::sendEchoRequest(cPacket *msg)
 {
     IPv6ControlInfo *ctrl = check_and_cast<IPv6ControlInfo*>(msg->removeControlInfo());
     ctrl->setProtocol(IP_PROT_IPv6_ICMP);
@@ -176,7 +176,7 @@
     }
 }
 
-void ICMPv6::sendErrorMessage(cMessage *transportPacket, IPv6ControlInfo *ctrl, ICMPv6Type type, int code)
+void ICMPv6::sendErrorMessage(cPacket *transportPacket, IPv6ControlInfo *ctrl, ICMPv6Type type, int code)
 {
     Enter_Method("sendErrorMessage(transportPacket, ctrl, type=%d, code=%d)", type, code);
 
Index: src/networklayer/icmpv6/ICMPv6.h
===================================================================
--- src/networklayer/icmpv6/ICMPv6.h	(revision 2038)
+++ src/networklayer/icmpv6/ICMPv6.h	(working copy)
@@ -56,7 +56,7 @@
      * so this function will wrap back the transport packet into the IP datagram
      * based on its IPControlInfo.
      */
-    virtual void sendErrorMessage(cMessage *transportPacket, IPv6ControlInfo *ctrl, ICMPv6Type type, int code);
+    virtual void sendErrorMessage(cPacket *transportPacket, IPv6ControlInfo *ctrl, ICMPv6Type type, int code);
 
   protected:
     // internal helper functions
@@ -95,7 +95,7 @@
      *  Ping a machine. The information needed to do this is in the cMessage
      *  parameter.  TODO where in cMessage? document!!!
      */
-    virtual void sendEchoRequest(cMessage *);
+    virtual void sendEchoRequest(cPacket *);
 
     /**
      * Validate the received IPv6 datagram before responding with error message.
Index: src/networklayer/icmpv6/ICMPv6Message.msg
===================================================================
--- src/networklayer/icmpv6/ICMPv6Message.msg	(revision 2038)
+++ src/networklayer/icmpv6/ICMPv6Message.msg	(working copy)
@@ -100,7 +100,7 @@
 //       as defined in RFC2463
 //    2. Any ICMP type with MSB set, i.e. >=128 is an Informational ICMP message
 //
-message ICMPv6Message
+packet ICMPv6Message
 {
     int type enum(ICMPv6Type);
         //int code; //TODO: this should be specific to different ICMP types.
@@ -110,23 +110,23 @@
 // Notes:
 //   1. As defined in RFC2463: Section 3
 //
-message ICMPv6DestUnreachableMsg extends ICMPv6Message
+packet ICMPv6DestUnreachableMsg extends ICMPv6Message
 {
     int code enum(ICMPv6DEST_UN);
 }
 
-message ICMPv6PacketTooBigMsg extends ICMPv6Message
+packet ICMPv6PacketTooBigMsg extends ICMPv6Message
 {
     int code; //Set to 0 by sender and ignored by receiver.
     int MTU; //MTU of next-hop link
 }
 
-message ICMPv6TimeExceededMsg extends ICMPv6Message
+packet ICMPv6TimeExceededMsg extends ICMPv6Message
 {
     int code enum(ICMPv6_TIME_EX);
 }
 
-message ICMPv6ParamProblemMsg extends ICMPv6Message
+packet ICMPv6ParamProblemMsg extends ICMPv6Message
 {
     int code enum(ICMPv6_PARAMETER_PROB);
 }
@@ -135,7 +135,7 @@
 // ICMPv6 Echo Request packet (RFC2463: Section 4).
 // Data is attached through encapsulation (see ICMPv6.cc)
 //
-message ICMPv6EchoRequestMsg extends ICMPv6Message
+packet ICMPv6EchoRequestMsg extends ICMPv6Message
 {
     int code; //set to 0.
     int identifier; // identifier to aid in matching Echo replies. May be Zero
@@ -146,7 +146,7 @@
 //
 // ICMPv6 Echo Reply packet. Data is attached through encapsulation (see ICMPv6.cc)
 //
-message ICMPv6EchoReplyMsg extends ICMPv6Message
+packet ICMPv6EchoReplyMsg extends ICMPv6Message
 {
     int code; //set to 0.
     int identifier; // identifier to aid in matching Echo replies. May be Zero
Index: src/networklayer/icmpv6/IPv6NDMessage.msg
===================================================================
--- src/networklayer/icmpv6/IPv6NDMessage.msg	(revision 2038)
+++ src/networklayer/icmpv6/IPv6NDMessage.msg	(working copy)
@@ -24,7 +24,7 @@
 }}
 
 
-message ICMPv6Message;
+packet ICMPv6Message;
 
 class noncobject IPv6Address;
 
@@ -55,7 +55,7 @@
 //    - Checksum
 //    - Reserved
 //
-message IPv6NDMessage extends ICMPv6Message
+packet IPv6NDMessage extends ICMPv6Message
 {
     //customize=true;
     int code = 0;
@@ -65,7 +65,7 @@
 // Router Solicitation Message Format
 // RFC 2461 Section 4.1
 //
-message IPv6RouterSolicitation extends IPv6NDMessage
+packet IPv6RouterSolicitation extends IPv6NDMessage
 {
     //Possible Options
     MACAddress sourceLinkLayerAddress;
@@ -75,7 +75,7 @@
 // Router Advertisement Message Format
 // RFC 2461 Section 4.2
 //
-message IPv6RouterAdvertisement extends IPv6NDMessage
+packet IPv6RouterAdvertisement extends IPv6NDMessage
 {
     //Additional ICMP fields
     unsigned int curHopLimit;
@@ -95,7 +95,7 @@
 // Neighbour Solicitation Message Format
 // RFC 2461 Section 4.3
 //
-message IPv6NeighbourSolicitation extends IPv6NDMessage
+packet IPv6NeighbourSolicitation extends IPv6NDMessage
 {
     //Additional ICMP fields
     IPv6Address targetAddress;// MUST NOT be a multicast address.
@@ -108,7 +108,7 @@
 // Neighbour Advertisement Message Format
 // RFC 2461 Section 4.4
 //
-message IPv6NeighbourAdvertisement extends IPv6NDMessage
+packet IPv6NeighbourAdvertisement extends IPv6NDMessage
 {
     //Additional ICMP fields
     bool routerFlag;
@@ -124,7 +124,7 @@
 // Redirect Message Format
 // RFC 2461 Section 4.5
 //
-message IPv6Redirect extends IPv6NDMessage
+packet IPv6Redirect extends IPv6NDMessage
 {
     //Additional ICMP fields
     IPv6Address targetAddress;
Index: src/networklayer/ipv6/IPv6ErrorHandling.cc
===================================================================
--- src/networklayer/ipv6/IPv6ErrorHandling.cc	(revision 2038)
+++ src/networklayer/ipv6/IPv6ErrorHandling.cc	(working copy)
@@ -36,7 +36,7 @@
 void IPv6ErrorHandling::handleMessage(cMessage *msg)
 {
     ICMPv6Message *icmpv6Msg = check_and_cast<ICMPv6Message *>(msg);
-    IPv6Datagram *d = check_and_cast<IPv6Datagram *>(msg->getEncapsulatedMsg());
+    IPv6Datagram *d = check_and_cast<IPv6Datagram *>(icmpv6Msg->getEncapsulatedMsg());
     int type = (int)icmpv6Msg->getType();
     int code;
     EV << " Type: " << type;
Index: src/networklayer/ipv6/IPv6.cc
===================================================================
--- src/networklayer/ipv6/IPv6.cc	(revision 2038)
+++ src/networklayer/ipv6/IPv6.cc	(working copy)
@@ -77,7 +77,7 @@
        (msg->getArrivalGate()->isName("icmpIn") && dynamic_cast<ICMPv6Message*>(msg)))//Added this for ICMP msgs from ICMP module-WEI
     {
         // packet from upper layers or ND: encapsulate and send out
-        handleMessageFromHL(msg);
+        handleMessageFromHL(PK(msg));
     }
     else
     {
@@ -90,7 +90,7 @@
         updateDisplayString();
 }
 
-InterfaceEntry *IPv6::getSourceInterfaceFrom(cMessage *msg)
+InterfaceEntry *IPv6::getSourceInterfaceFrom(cPacket *msg)
 {
     cGate *g = msg->getArrivalGate();
     return g ? ift->getInterfaceByNetworkLayerGateIndex(g->getIndex()) : NULL;
@@ -125,7 +125,7 @@
         routeMulticastPacket(datagram, NULL, getSourceInterfaceFrom(datagram));
 }
 
-void IPv6::handleMessageFromHL(cMessage *msg)
+void IPv6::handleMessageFromHL(cPacket *msg)
 {
     // if no interface exists, do not send datagram
     if (ift->getNumInterfaces() == 0)
@@ -421,7 +421,7 @@
 */
     // decapsulate and send on appropriate output gate
     int protocol = datagram->getTransportProtocol();
-    cMessage *packet = decapsulate(datagram);
+    cPacket *packet = decapsulate(datagram);
 
     if (protocol==IP_PROT_IPv6_ICMP && dynamic_cast<IPv6NDMessage*>(packet))
     {
@@ -476,11 +476,11 @@
 }
 
 
-cMessage *IPv6::decapsulate(IPv6Datagram *datagram)
+cPacket *IPv6::decapsulate(IPv6Datagram *datagram)
 {
     // decapsulate transport packet
     InterfaceEntry *fromIE = getSourceInterfaceFrom(datagram);
-    cMessage *packet = datagram->decapsulate();
+    cPacket *packet = datagram->decapsulate();
 
     // create and fill in control info
     IPv6ControlInfo *controlInfo = new IPv6ControlInfo();
@@ -499,7 +499,7 @@
     return packet;
 }
 
-IPv6Datagram *IPv6::encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE)
+IPv6Datagram *IPv6::encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE)
 {
     IPv6ControlInfo *controlInfo = check_and_cast<IPv6ControlInfo*>(transportPacket->removeControlInfo());
 
Index: src/networklayer/ipv6/IPv6Datagram.msg
===================================================================
--- src/networklayer/ipv6/IPv6Datagram.msg	(revision 2038)
+++ src/networklayer/ipv6/IPv6Datagram.msg	(working copy)
@@ -42,7 +42,7 @@
 //    - payload length: will be calculated from encapsulated message length
 //      and extension headers' length
 //
-message IPv6Datagram
+packet IPv6Datagram
 {
     @customize(true);
 
Index: src/networklayer/ipv6/IPv6.h
===================================================================
--- src/networklayer/ipv6/IPv6.h	(revision 2038)
+++ src/networklayer/ipv6/IPv6.h	(working copy)
@@ -57,7 +57,7 @@
 
   protected:
     // utility: look up interface from getArrivalGate()
-    virtual InterfaceEntry *getSourceInterfaceFrom(cMessage *msg);
+    virtual InterfaceEntry *getSourceInterfaceFrom(cPacket *msg);
 
     // utility: show current statistics above the icon
     virtual void updateDisplayString();
@@ -65,7 +65,7 @@
     /**
      * Encapsulate packet coming from higher layers into IPv6Datagram
      */
-    virtual IPv6Datagram *encapsulate(cMessage *transportPacket, InterfaceEntry *&destIE);
+    virtual IPv6Datagram *encapsulate(cPacket *transportPacket, InterfaceEntry *&destIE);
 
     /**
      * Handle IPv6Datagram messages arriving from lower layer.
@@ -77,7 +77,7 @@
      * Handle messages (typically packets to be send in IPv6) from transport or ICMP.
      * Invokes encapsulate(), then routePacket().
      */
-    virtual void handleMessageFromHL(cMessage *msg);
+    virtual void handleMessageFromHL(cPacket *msg);
 
     /**
      * Handle incoming ICMP messages.
@@ -114,7 +114,7 @@
     /**
      * Decapsulate and return encapsulated packet after attaching IPv6ControlInfo.
      */
-    virtual cMessage *decapsulate(IPv6Datagram *datagram);
+    virtual cPacket *decapsulate(IPv6Datagram *datagram);
 
     /**
      * Last hoplimit check, then send datagram on the given interface.
Index: src/networklayer/extras/FailureManager.cc
===================================================================
--- src/networklayer/extras/FailureManager.cc	(revision 2038)
+++ src/networklayer/extras/FailureManager.cc	(working copy)
@@ -116,7 +116,7 @@
         cGate *out = old->gate(outs, i);
         if(out->isConnected())
         {
-            cGate *to = out->getToGate();
+            cGate *to = out->getNextGate();
             cChannel *ch = check_and_cast<cChannel*>(out->getChannel()->dup());
             out->disconnect();
             n->gate(outs, i)->connectTo(to, ch);
@@ -128,7 +128,7 @@
         cGate *in = old->gate(ins, i);
         if (in->isConnected())
         {
-            cGate *from = in->getFromGate();
+            cGate *from = in->getPreviousGate();
             cChannel *ch = check_and_cast<cChannel*>(from->getChannel()->dup());
             from->disconnect();
             from->connectTo(n->gate(ins, i), ch);
Index: src/networklayer/common/InterfaceTable.cc
===================================================================
--- src/networklayer/common/InterfaceTable.cc	(revision 2038)
+++ src/networklayer/common/InterfaceTable.cc	(working copy)
@@ -175,16 +175,16 @@
         if (!g) continue;
 
         // find the host/router's gates that internally connect to this interface
-        if (g->getType()==cGate::OUTPUT && g->getToGate() && g->getToGate()->getOwnerModule()==host)
-            entry->setNodeOutputGateId(g->getToGate()->getId());
-        if (g->getType()==cGate::INPUT && g->getFromGate() && g->getFromGate()->getOwnerModule()==host)
-            entry->setNodeInputGateId(g->getFromGate()->getId());
+        if (g->getType()==cGate::OUTPUT && g->getNextGate() && g->getNextGate()->getOwnerModule()==host)
+            entry->setNodeOutputGateId(g->getNextGate()->getId());
+        if (g->getType()==cGate::INPUT && g->getPreviousGate() && g->getPreviousGate()->getOwnerModule()==host)
+            entry->setNodeInputGateId(g->getPreviousGate()->getId());
 
         // find the gate index of networkLayer/networkLayer6/mpls that connects to this interface
-        if (g->getType()==cGate::OUTPUT && g->getToGate() && g->getToGate()->isName("ifIn"))
-            nwlayerInGate = g->getToGate();
-        if (g->getType()==cGate::INPUT && g->getFromGate() && g->getFromGate()->isName("ifOut"))
-            nwlayerOutGate = g->getFromGate();
+        if (g->getType()==cGate::OUTPUT && g->getNextGate() && g->getNextGate()->isName("ifIn"))
+            nwlayerInGate = g->getNextGate();
+        if (g->getType()==cGate::INPUT && g->getPreviousGate() && g->getPreviousGate()->isName("ifOut"))
+            nwlayerOutGate = g->getPreviousGate();
     }
 
     // consistency checks
Index: src/networklayer/mpls/MPLSPacket.cc
===================================================================
--- src/networklayer/mpls/MPLSPacket.cc	(revision 2038)
+++ src/networklayer/mpls/MPLSPacket.cc	(working copy)
@@ -18,7 +18,7 @@
 #include "MPLSPacket.h"
 
 // constructors
-MPLSPacket::MPLSPacket(const char *name) : cMessage(name)
+MPLSPacket::MPLSPacket(const char *name) : cPacket(name)
 {
 }
 
@@ -31,7 +31,7 @@
 // assignment operator
 MPLSPacket & MPLSPacket::operator=(const MPLSPacket & p)
 {
-    cMessage::operator=(p);
+    cPacket::operator=(p);
     return *this;
 }
 
Index: src/networklayer/mpls/MPLSPacket.h
===================================================================
--- src/networklayer/mpls/MPLSPacket.h	(revision 2038)
+++ src/networklayer/mpls/MPLSPacket.h	(working copy)
@@ -23,7 +23,7 @@
 /**
  * Represents a packet with MPLS headers
  */
-class INET_API MPLSPacket: public cMessage
+class INET_API MPLSPacket: public cPacket
 {
   protected:
     typedef std::stack<int> LabelStack;
Index: src/networklayer/ted/LinkStatePacket.msg
===================================================================
--- src/networklayer/ted/LinkStatePacket.msg	(revision 2038)
+++ src/networklayer/ted/LinkStatePacket.msg	(working copy)
@@ -28,7 +28,7 @@
 // LinkStateRouting module which implements a minimalistic link state routing
 // protocol.
 //
-message LinkStateMsg
+packet LinkStateMsg
 {
     TELinkStateInfo linkInfo[];
 
Index: src/world/ScenarioManager.cc
===================================================================
--- src/world/ScenarioManager.cc	(revision 2038)
+++ src/world/ScenarioManager.cc	(working copy)
@@ -176,7 +176,7 @@
     bubble((std::string("setting channel attr: ")+attrAttr+" = "+valueAttr).c_str());
 
     // make sure gate is connected at all
-    if (!g->getToGate())
+    if (!g->getNextGate())
         error("gate '%s' is not connected at %s", g->getFullPath().c_str(), node->getSourceLocation());
 
     // find channel (or add one?)
Index: src/linklayer/ppp/PPPFrame.msg
===================================================================
--- src/linklayer/ppp/PPPFrame.msg	(revision 2038)
+++ src/linklayer/ppp/PPPFrame.msg	(working copy)
@@ -41,7 +41,7 @@
 // Protocol field is not modelled because types of encapsulated messages
 // wil be determined from their class (using C++ dynamic_cast).
 //
-message PPPFrame
+packet PPPFrame
 {
 }
 
Index: src/linklayer/ppp/PPP.cc
===================================================================
--- src/linklayer/ppp/PPP.cc	(revision 2038)
+++ src/linklayer/ppp/PPP.cc	(working copy)
@@ -70,10 +70,10 @@
         physOutGate = gate("phys$o");
 
         // we're connected if other end of connection path is an input gate
-        bool connected = physOutGate->getDestinationGate()->getType()==cGate::INPUT;
+        bool connected = physOutGate->getPathEndGate()->getType()==cGate::INPUT;
 
         // if we're connected, get the gate with transmission rate
-        datarateChannel = connected ? physOutGate->getDatarateChannel() : NULL;
+        datarateChannel = connected ? physOutGate->getTransmissionChannel() : NULL;
         double datarate = connected ? datarateChannel->par("datarate").doubleValue() : 0;
 
         // register our interface entry in IInterfaceTable
@@ -151,7 +151,7 @@
 }
 
 
-void PPP::startTransmitting(cMessage *msg)
+void PPP::startTransmitting(cPacket *msg)
 {
     // if there's any control info, remove it; then encapsulate the packet
     delete msg->removeControlInfo();
@@ -161,7 +161,7 @@
     if (hasSubscribers)
     {
         // fire notification
-        notifDetails.setMessage(pppFrame);
+        notifDetails.setPacket(pppFrame);
         nb->fireChangeNotification(NF_PP_TX_BEGIN, &notifDetails);
     }
 
@@ -191,14 +191,14 @@
         if (hasSubscribers)
         {
             // fire notification
-            notifDetails.setMessage(NULL);
+            notifDetails.setPacket(NULL);
             nb->fireChangeNotification(NF_PP_TX_END, &notifDetails);
         }
 
         if (!txQueue.empty())
         {
-            msg = (cMessage *) txQueue.pop();
-            startTransmitting(msg);
+            cPacket *pk = (cPacket *) txQueue.pop();
+            startTransmitting(pk);
             numSent++;
         }
         else if (queueModule)
@@ -212,12 +212,12 @@
         if (hasSubscribers)
         {
             // fire notification
-            notifDetails.setMessage(msg);
+            notifDetails.setPacket(PK(msg));
             nb->fireChangeNotification(NF_PP_RX_END, &notifDetails);
         }
 
         // check for bit errors
-        if (msg->hasBitError())
+        if (PK(msg)->hasBitError())
         {
             EV << "Bit error in " << msg << endl;
             numBitErr++;
@@ -226,7 +226,7 @@
         else
         {
             // pass up payload
-            cMessage *payload = decapsulate(check_and_cast<PPPFrame *>(msg));
+            cPacket *payload = decapsulate(check_and_cast<PPPFrame *>(msg));
             numRcvdOK++;
             send(payload,"netwOut");
         }
@@ -251,7 +251,7 @@
         {
             // We are idle, so we can start transmitting right away.
             EV << "Received " << msg << " for transmission\n";
-            startTransmitting(msg);
+            startTransmitting(PK(msg));
             numSent++;
         }
     }
@@ -325,7 +325,7 @@
         updateHasSubcribers();
 }
 
-PPPFrame *PPP::encapsulate(cMessage *msg)
+PPPFrame *PPP::encapsulate(cPacket *msg)
 {
     PPPFrame *pppFrame = new PPPFrame(msg->getName());
     pppFrame->setByteLength(PPP_OVERHEAD_BYTES);
@@ -333,9 +333,9 @@
     return pppFrame;
 }
 
-cMessage *PPP::decapsulate(PPPFrame *pppFrame)
+cPacket *PPP::decapsulate(PPPFrame *pppFrame)
 {
-    cMessage *msg = pppFrame->decapsulate();
+    cPacket *msg = pppFrame->decapsulate();
     delete pppFrame;
     return msg;
 }
Index: src/linklayer/ppp/PPP.h
===================================================================
--- src/linklayer/ppp/PPP.h	(revision 2038)
+++ src/linklayer/ppp/PPP.h	(working copy)
@@ -60,9 +60,9 @@
 
   protected:
     virtual InterfaceEntry *registerInterface(double datarate);
-    virtual void startTransmitting(cMessage *msg);
-    virtual PPPFrame *encapsulate(cMessage *msg);
-    virtual cMessage *decapsulate(PPPFrame *pppFrame);
+    virtual void startTransmitting(cPacket *msg);
+    virtual PPPFrame *encapsulate(cPacket *msg);
+    virtual cPacket *decapsulate(PPPFrame *pppFrame);
     virtual void displayBusy();
     virtual void displayIdle();
     virtual void updateDisplayString();
Index: src/linklayer/ppp/ThruputMeter.cc
===================================================================
--- src/linklayer/ppp/ThruputMeter.cc	(revision 2038)
+++ src/linklayer/ppp/ThruputMeter.cc	(working copy)
@@ -44,7 +44,7 @@
 
 void ThruputMeter::handleMessage(cMessage *msg)
 {
-    updateStats(simTime(), msg->getBitLength());
+    updateStats(simTime(), PK(msg)->getBitLength());
     send(msg, "out");
 }
 
Index: src/linklayer/ieee80211/mac/Ieee80211Frame.msg
===================================================================
--- src/linklayer/ieee80211/mac/Ieee80211Frame.msg	(revision 2038)
+++ src/linklayer/ieee80211/mac/Ieee80211Frame.msg	(working copy)
@@ -64,7 +64,7 @@
 // Frame control format fields not supported by this model are omitted:
 // MoreFlag, PowerMgmt, MoreData, WEP, Order.
 //
-message Ieee80211Frame
+packet Ieee80211Frame
 {
     byteLength = 14;
     short type enum(Ieee80211FrameType); // type and subtype
@@ -80,14 +80,14 @@
 //
 // Format of a 802.11 frame with address1 present, like ACK and CTS
 //
-message Ieee80211OneAddressFrame extends Ieee80211Frame
+packet Ieee80211OneAddressFrame extends Ieee80211Frame
 {
 }
 
 //
 // Format of the 802.11 ACK frame
 //
-message Ieee80211ACKFrame extends Ieee80211OneAddressFrame
+packet Ieee80211ACKFrame extends Ieee80211OneAddressFrame
 {
     type = ST_ACK;
 }
@@ -95,7 +95,7 @@
 //
 // Format of a 802.11 frame with address1 and address2 present
 //
-message Ieee80211TwoAddressFrame extends Ieee80211OneAddressFrame
+packet Ieee80211TwoAddressFrame extends Ieee80211OneAddressFrame
 {
     byteLength = 20;
     MACAddress transmitterAddress; // aka address2
@@ -104,7 +104,7 @@
 //
 // Format of the 802.11 RTS frame
 //
-message Ieee80211RTSFrame extends Ieee80211TwoAddressFrame
+packet Ieee80211RTSFrame extends Ieee80211TwoAddressFrame
 {
     type = ST_RTS;
 }
@@ -112,7 +112,7 @@
 //
 // Format of the 802.11 CTS frame
 //
-message Ieee80211CTSFrame extends Ieee80211OneAddressFrame
+packet Ieee80211CTSFrame extends Ieee80211OneAddressFrame
 {
     type = ST_CTS;
 }
@@ -120,7 +120,7 @@
 //
 // Common base class for 802.11 data and management frames
 //
-message Ieee80211DataOrMgmtFrame extends Ieee80211TwoAddressFrame
+packet Ieee80211DataOrMgmtFrame extends Ieee80211TwoAddressFrame
 {
     byteLength = 28;
     MACAddress address3;
@@ -131,7 +131,7 @@
 //
 // Format of the 802.11 data frame
 //
-message Ieee80211DataFrame extends Ieee80211DataOrMgmtFrame
+packet Ieee80211DataFrame extends Ieee80211DataOrMgmtFrame
 {
     type = ST_DATA;
     byteLength = 34;
@@ -141,7 +141,7 @@
 //
 // Base class for 802.11 management frames (subclasses will add frame body contents)
 //
-message Ieee80211ManagementFrame extends Ieee80211DataOrMgmtFrame
+packet Ieee80211ManagementFrame extends Ieee80211DataOrMgmtFrame
 {
 }
 
Index: src/linklayer/ieee80211/mac/Ieee80211Mac.cc
===================================================================
--- src/linklayer/ieee80211/mac/Ieee80211Mac.cc	(revision 2038)
+++ src/linklayer/ieee80211/mac/Ieee80211Mac.cc	(working copy)
@@ -235,7 +235,7 @@
     handleWithFSM(msg);
 }
 
-void Ieee80211Mac::handleUpperMsg(cMessage *msg)
+void Ieee80211Mac::handleUpperMsg(cPacket *msg)
 {
     // check if it's a command from the mgmt layer
     if (msg->getBitLength()==0 && msg->getKind()!=0)
@@ -306,7 +306,7 @@
     }
 }
 
-void Ieee80211Mac::handleLowerMsg(cMessage *msg)
+void Ieee80211Mac::handleLowerMsg(cPacket *msg)
 {
     EV << "received message from lower layer: " << msg << endl;
 
Index: src/linklayer/ieee80211/mac/Ieee80211Mac.h
===================================================================
--- src/linklayer/ieee80211/mac/Ieee80211Mac.h	(revision 2038)
+++ src/linklayer/ieee80211/mac/Ieee80211Mac.h	(working copy)
@@ -1,5 +1,5 @@
 //
-// Copyright (C) 2006 Andras Varga and Levente Mszros
+// Copyright (C) 2006 Andras Varga and Levente Mszros
 //
 // This program is free software; you can redistribute it and/or
 // modify it under the terms of the GNU General Public License
@@ -268,10 +268,10 @@
     virtual void handleSelfMsg(cMessage *msg);
 
     /** @brief Handle messages from upper layer */
-    virtual void handleUpperMsg(cMessage *msg);
+    virtual void handleUpperMsg(cPacket *msg);
 
     /** @brief Handle messages from lower (physical) layer */
-    virtual void handleLowerMsg(cMessage *msg);
+    virtual void handleLowerMsg(cPacket *msg);
 
     /** @brief Handle all kinds of messages and notifications with the state machine */
     virtual void handleWithFSM(cMessage *msg);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.cc	(working copy)
@@ -176,7 +176,7 @@
     }
 }
 
-void Ieee80211MgmtSTA::handleUpperMessage(cMessage *msg)
+void Ieee80211MgmtSTA::handleUpperMessage(cPacket *msg)
 {
     Ieee80211DataFrame *frame = encapsulate(msg);
     sendOrEnqueue(frame);
@@ -203,7 +203,7 @@
     delete ctrl;
 }
 
-Ieee80211DataFrame *Ieee80211MgmtSTA::encapsulate(cMessage *msg)
+Ieee80211DataFrame *Ieee80211MgmtSTA::encapsulate(cPacket *msg)
 {
     Ieee80211DataFrame *frame = new Ieee80211DataFrame(msg->getName());
 
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTA.h	(working copy)
@@ -111,13 +111,13 @@
     virtual void handleTimer(cMessage *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
-    virtual void handleUpperMessage(cMessage *msg);
+    virtual void handleUpperMessage(cPacket *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl);
 
     /** Utility function for handleUpperMessage() */
-    virtual Ieee80211DataFrame *encapsulate(cMessage *msg);
+    virtual Ieee80211DataFrame *encapsulate(cPacket *msg);
 
     /** Utility function: sends authentication request */
     virtual void startAuthentication(APInfo *ap, simtime_t timeout);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPBase.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPBase.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPBase.cc	(working copy)
@@ -28,7 +28,7 @@
 
     if (stage==0)
     {
-        hasRelayUnit = gate("uppergateOut")->getDestinationGate()->isConnected();
+        hasRelayUnit = gate("uppergateOut")->getPathEndGate()->isConnected();
         WATCH(hasRelayUnit);
     }
 }
@@ -58,7 +58,7 @@
     //XXX set ethertype
 
     // encapsulate the payload in there
-    cMessage *payload = frame->decapsulate();
+    cPacket *payload = frame->decapsulate();
     delete frame;
     ASSERT(payload!=NULL);
     ethframe->encapsulate(payload);
@@ -78,7 +78,7 @@
     frame->setAddress3(ethframe->getSrc());
 
     // encapsulate payload
-    cMessage *payload = ethframe->decapsulate();
+    cPacket *payload = ethframe->decapsulate();
     if (!payload)
         error("received empty EtherFrame from upper layer");
     frame->encapsulate(payload);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.cc	(working copy)
@@ -39,7 +39,7 @@
     ASSERT(false);
 }
 
-void Ieee80211MgmtSTASimplified::handleUpperMessage(cMessage *msg)
+void Ieee80211MgmtSTASimplified::handleUpperMessage(cPacket *msg)
 {
     Ieee80211DataFrame *frame = encapsulate(msg);
     sendOrEnqueue(frame);
@@ -50,7 +50,7 @@
     error("handleCommand(): no commands supported");
 }
 
-Ieee80211DataFrame *Ieee80211MgmtSTASimplified::encapsulate(cMessage *msg)
+Ieee80211DataFrame *Ieee80211MgmtSTASimplified::encapsulate(cPacket *msg)
 {
     Ieee80211DataFrame *frame = new Ieee80211DataFrame(msg->getName());
 
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtSTASimplified.h	(working copy)
@@ -46,13 +46,13 @@
     virtual void handleTimer(cMessage *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
-    virtual void handleUpperMessage(cMessage *msg);
+    virtual void handleUpperMessage(cPacket *msg);
 
     /** Implements abstract Ieee80211MgmtBase method -- throws an error (no commands supported) */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl);
 
     /** Utility function for handleUpperMessage() */
-    virtual Ieee80211DataFrame *encapsulate(cMessage *msg);
+    virtual Ieee80211DataFrame *encapsulate(cPacket *msg);
 
     /** Called by the NotificationBoard whenever a change occurs we're interested in */
     virtual void receiveChangeNotification(int category, const cPolymorphic *details);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.cc	(working copy)
@@ -76,7 +76,7 @@
     }
 }
 
-void Ieee80211MgmtAP::handleUpperMessage(cMessage *msg)
+void Ieee80211MgmtAP::handleUpperMessage(cPacket *msg)
 {
     // must be an EtherFrame frame arriving from MACRelayUnit, that is,
     // bridged from another interface of the AP (probably Ethernet).
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAP.h	(working copy)
@@ -71,7 +71,7 @@
     virtual void handleTimer(cMessage *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
-    virtual void handleUpperMessage(cMessage *msg);
+    virtual void handleUpperMessage(cPacket *msg);
 
     /** Implements abstract Ieee80211MgmtBase method -- throws an error (no commands supported) */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.cc	(working copy)
@@ -36,7 +36,7 @@
     ASSERT(false);
 }
 
-void Ieee80211MgmtAPSimplified::handleUpperMessage(cMessage *msg)
+void Ieee80211MgmtAPSimplified::handleUpperMessage(cPacket *msg)
 {
     // convert Ethernet frames arriving from MACRelayUnit (i.e. from
     // the AP's other Ethernet or wireless interfaces)
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAPSimplified.h	(working copy)
@@ -42,7 +42,7 @@
     virtual void handleTimer(cMessage *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
-    virtual void handleUpperMessage(cMessage *msg);
+    virtual void handleUpperMessage(cPacket *msg);
 
     /** Implements abstract Ieee80211MgmtBase method -- throws an error (no commands supported) */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.cc	(working copy)
@@ -89,16 +89,17 @@
     else
     {
         // packet from upper layers, to be sent out
-        EV << "Packet arrived from upper layers: " << msg << "\n";
-        if (msg->getByteLength() > 2312)
+        cPacket *pk = PK(msg);
+        EV << "Packet arrived from upper layers: " << pk << "\n";
+        if (pk->getByteLength() > 2312)
             error("message from higher layer (%s)%s is too long for 802.11b, %d bytes (fragmentation is not supported yet)",
-                  msg->getClassName(), msg->getName(), msg->getByteLength());
+                  pk->getClassName(), pk->getName(), pk->getByteLength());
 
-        handleUpperMessage(msg);
+        handleUpperMessage(pk);
     }
 }
 
-void Ieee80211MgmtBase::sendOrEnqueue(cMessage *frame)
+void Ieee80211MgmtBase::sendOrEnqueue(cPacket *frame)
 {
     PassiveQueueBase::handleMessage(frame);
 }
@@ -158,9 +159,9 @@
     numMgmtFramesDropped++;
 }
 
-cMessage *Ieee80211MgmtBase::decapsulate(Ieee80211DataFrame *frame)
+cPacket *Ieee80211MgmtBase::decapsulate(Ieee80211DataFrame *frame)
 {
-    cMessage *payload = frame->decapsulate();
+    cPacket *payload = frame->decapsulate();
 
     Ieee802Ctrl *ctrl = new Ieee802Ctrl();
     ctrl->setSrc(frame->getAddress3());
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtBase.h	(working copy)
@@ -65,13 +65,13 @@
     virtual void handleTimer(cMessage *frame) = 0;
 
     /** Should be redefined to encapsulate and enqueue msgs from higher layers */
-    virtual void handleUpperMessage(cMessage *msg) = 0;
+    virtual void handleUpperMessage(cPacket *msg) = 0;
 
     /** Should be redefined to handle commands from the "agent" (if present) */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl) = 0;
 
     /** Utility method for implementing handleUpperMessage(): gives the message to PassiveQueueBase */
-    virtual void sendOrEnqueue(cMessage *frame);
+    virtual void sendOrEnqueue(cPacket *frame);
 
     /** Redefined from PassiveQueueBase. */
     virtual bool enqueue(cMessage *msg);
@@ -86,7 +86,7 @@
     virtual void dropManagementFrame(Ieee80211ManagementFrame *frame);
 
     /** Utility method to decapsulate a data frame (encapsulation depends on adhoc/STA/AP) */
-    virtual cMessage *decapsulate(Ieee80211DataFrame *frame);
+    virtual cPacket *decapsulate(Ieee80211DataFrame *frame);
 
     /** Utility method: sends the packet to the upper layer */
     virtual void sendUp(cMessage *msg);
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.cc
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.cc	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.cc	(working copy)
@@ -34,7 +34,7 @@
     ASSERT(false);
 }
 
-void Ieee80211MgmtAdhoc::handleUpperMessage(cMessage *msg)
+void Ieee80211MgmtAdhoc::handleUpperMessage(cPacket *msg)
 {
     Ieee80211DataFrame *frame = encapsulate(msg);
     sendOrEnqueue(frame);
@@ -45,7 +45,7 @@
     error("handleCommand(): no commands supported");
 }
 
-Ieee80211DataFrame *Ieee80211MgmtAdhoc::encapsulate(cMessage *msg)
+Ieee80211DataFrame *Ieee80211MgmtAdhoc::encapsulate(cPacket *msg)
 {
     Ieee80211DataFrame *frame = new Ieee80211DataFrame(msg->getName());
 
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtFrames.msg	(working copy)
@@ -26,7 +26,7 @@
 
 class noncobject MACAddress;
 
-message Ieee80211ManagementFrame;
+packet Ieee80211ManagementFrame;
 
 
 //
@@ -220,7 +220,7 @@
 //
 // Authentication frame format (management frame + body)
 //
-message Ieee80211AuthenticationFrame extends Ieee80211ManagementFrame
+packet Ieee80211AuthenticationFrame extends Ieee80211ManagementFrame
 {
     type = ST_AUTHENTICATION;
     byteLength = 28+getBody().getBodyLength();
@@ -230,7 +230,7 @@
 //
 // De-authentication frame format (management frame + body)
 //
-message Ieee80211DeauthenticationFrame extends Ieee80211ManagementFrame
+packet Ieee80211DeauthenticationFrame extends Ieee80211ManagementFrame
 {
     type = ST_DEAUTHENTICATION;
     byteLength = 28+getBody().getBodyLength();
@@ -240,7 +240,7 @@
 //
 // Dis-association frame format (management frame + body) (same as De-authentication)
 //
-message Ieee80211DisassociationFrame extends Ieee80211ManagementFrame
+packet Ieee80211DisassociationFrame extends Ieee80211ManagementFrame
 {
     type = ST_DISASSOCIATION;
     byteLength = 28+getBody().getBodyLength();
@@ -250,7 +250,7 @@
 //
 // Probe request frame format (management frame + body)
 //
-message Ieee80211ProbeRequestFrame extends Ieee80211ManagementFrame
+packet Ieee80211ProbeRequestFrame extends Ieee80211ManagementFrame
 {
     type = ST_PROBEREQUEST;
     byteLength = 28+getBody().getBodyLength();
@@ -260,7 +260,7 @@
 //
 // Association request frame format (management frame + body)
 //
-message Ieee80211AssociationRequestFrame extends Ieee80211ManagementFrame
+packet Ieee80211AssociationRequestFrame extends Ieee80211ManagementFrame
 {
     type = ST_ASSOCIATIONREQUEST;
     byteLength = 28+getBody().getBodyLength();
@@ -270,7 +270,7 @@
 //
 // Re-association request frame format (management frame + body) (same as association)
 //
-message Ieee80211ReassociationRequestFrame extends Ieee80211ManagementFrame
+packet Ieee80211ReassociationRequestFrame extends Ieee80211ManagementFrame
 {
     type = ST_REASSOCIATIONREQUEST;
     byteLength = 28+getBody().getBodyLength();
@@ -280,7 +280,7 @@
 //
 // Association response frame format (management frame + body)
 //
-message Ieee80211AssociationResponseFrame extends Ieee80211ManagementFrame
+packet Ieee80211AssociationResponseFrame extends Ieee80211ManagementFrame
 {
     type = ST_ASSOCIATIONRESPONSE;
     byteLength = 28+getBody().getBodyLength();
@@ -290,7 +290,7 @@
 //
 // Re-association response frame format (management frame + body)
 //
-message Ieee80211ReassociationResponseFrame extends Ieee80211ManagementFrame
+packet Ieee80211ReassociationResponseFrame extends Ieee80211ManagementFrame
 {
     type = ST_REASSOCIATIONRESPONSE;
     byteLength = 28+getBody().getBodyLength();
@@ -300,7 +300,7 @@
 //
 // Beacon frame format (management frame + body)
 //
-message Ieee80211BeaconFrame extends Ieee80211ManagementFrame
+packet Ieee80211BeaconFrame extends Ieee80211ManagementFrame
 {
     type = ST_BEACON;
     byteLength = 28+getBody().getBodyLength();
@@ -310,7 +310,7 @@
 //
 // Probe response frame format (management frame + body); same as Beacon
 //
-message Ieee80211ProbeResponseFrame extends Ieee80211ManagementFrame
+packet Ieee80211ProbeResponseFrame extends Ieee80211ManagementFrame
 {
     type = ST_PROBERESPONSE;
     byteLength = 28+getBody().getBodyLength();
Index: src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.h
===================================================================
--- src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.h	(revision 2038)
+++ src/linklayer/ieee80211/mgmt/Ieee80211MgmtAdhoc.h	(working copy)
@@ -40,13 +40,13 @@
     virtual void handleTimer(cMessage *msg);
 
     /** Implements abstract Ieee80211MgmtBase method */
-    virtual void handleUpperMessage(cMessage *msg);
+    virtual void handleUpperMessage(cPacket *msg);
 
     /** Implements abstract Ieee80211MgmtBase method -- throws an error (no commands supported) */
     virtual void handleCommand(int msgkind, cPolymorphic *ctrl);
 
     /** Utility function for handleUpperMessage() */
-    virtual Ieee80211DataFrame *encapsulate(cMessage *msg);
+    virtual Ieee80211DataFrame *encapsulate(cPacket *msg);
 
     /** Called by the NotificationBoard whenever a change occurs we're interested in */
     virtual void receiveChangeNotification(int category, const cPolymorphic *details);
Index: src/linklayer/etherswitch/MACRelayUnitNP.cc
===================================================================
--- src/linklayer/etherswitch/MACRelayUnitNP.cc	(revision 2038)
+++ src/linklayer/etherswitch/MACRelayUnitNP.cc	(working copy)
@@ -1,3 +1,4 @@
+#if 0  //XXX
 /*
  * Copyright (C) 2003 CTIE, Monash University
  *
@@ -104,7 +105,7 @@
     else
     {
         // Self message signal used to indicate a frame has finished processing
-        processFrame(msg);
+        processFrame(PK(msg));
     }
 }
 
@@ -156,7 +157,7 @@
     bufferLevel.record(bufferUsed);
 }
 
-void MACRelayUnitNP::processFrame(cMessage *msg)
+void MACRelayUnitNP::processFrame(cPacket *msg)
 {
     int cpu = msg->getKind();
     EtherFrame *frame = (EtherFrame *) msg->decapsulate();
@@ -192,4 +193,4 @@
     recordScalar("processed frames", numProcessedFrames);
     recordScalar("dropped frames", numDroppedFrames);
 }
-
+#endif //XXX
Index: src/linklayer/etherswitch/MACRelayUnitNP.h
===================================================================
--- src/linklayer/etherswitch/MACRelayUnitNP.h	(revision 2038)
+++ src/linklayer/etherswitch/MACRelayUnitNP.h	(working copy)
@@ -83,7 +83,7 @@
      * Triggered when a frame has completed processing, it routes the frame
      * to the appropriate port, and starts processing the next frame.
      */
-    virtual void processFrame(cMessage *msg);
+    virtual void processFrame(cPacket *msg);
 };
 
 #endif
Index: src/linklayer/mfcore/WirelessMacBase.h
===================================================================
--- src/linklayer/mfcore/WirelessMacBase.h	(revision 2038)
+++ src/linklayer/mfcore/WirelessMacBase.h	(working copy)
@@ -66,10 +66,10 @@
     virtual void handleSelfMsg(cMessage *msg) = 0;
 
     /** @brief Handle messages from upper layer */
-    virtual void handleUpperMsg(cMessage *msg) = 0;
+    virtual void handleUpperMsg(cPacket *msg) = 0;
 
     /** @brief Handle messages from lower layer */
-    virtual void handleLowerMsg(cMessage *msg) = 0;
+    virtual void handleLowerMsg(cPacket *msg) = 0;
 
     virtual bool isUpperMsg(cMessage *msg);
     virtual bool isLowerMsg(cMessage *msg);
Index: src/linklayer/mfcore/BasicSnrEval.cc
===================================================================
--- src/linklayer/mfcore/BasicSnrEval.cc	(revision 2038)
+++ src/linklayer/mfcore/BasicSnrEval.cc	(working copy)
@@ -80,7 +80,7 @@
 {
     if (msg->getArrivalGateId() == uppergateIn)
     {
-        AirFrame *frame = encapsMsg(msg);
+        AirFrame *frame = encapsMsg(PK(msg));
         handleUpperMsg(frame);
     }
     else if (msg->isSelfMessage())
@@ -135,7 +135,7 @@
  * headerLength, sets the pSend (transmitterPower) and returns the
  * AirFrame.
  */
-AirFrame *BasicSnrEval::encapsMsg(cMessage *msg)
+AirFrame *BasicSnrEval::encapsMsg(cPacket *msg)
 {
     AirFrame *frame = createCapsulePkt();
     frame->setName(msg->getName());
@@ -156,7 +156,7 @@
  *
  * Just redefine this function in such a case!
  */
-double BasicSnrEval::calcDuration(cMessage *af)
+double BasicSnrEval::calcDuration(cPacket *af)
 {
     double duration;
     duration = (double) af->getBitLength() / (double) bitrate;
Index: src/linklayer/mfcore/BasicSnrEval.h
===================================================================
--- src/linklayer/mfcore/BasicSnrEval.h	(revision 2038)
+++ src/linklayer/mfcore/BasicSnrEval.h	(working copy)
@@ -132,11 +132,11 @@
     virtual void sendDown(AirFrame *msg);
 
     /** @brief Encapsulates a MAC frame into an Air Frame*/
-    virtual AirFrame *encapsMsg(cMessage *msg);
+    virtual AirFrame *encapsMsg(cPacket *msg);
     /*@}*/
 
     /** @brief This function calculates the duration of the AirFrame */
-    virtual double calcDuration(cMessage*);
+    virtual double calcDuration(cPacket *);
 
     /** @brief Returns the channel we're listening on. This version always returns 0 (single radio channel supported) */
     virtual int getChannelNumber() const {return 0;}
Index: src/linklayer/mfcore/TransmComplete.msg
===================================================================
--- src/linklayer/mfcore/TransmComplete.msg	(revision 2038)
+++ src/linklayer/mfcore/TransmComplete.msg	(working copy)
@@ -33,6 +33,6 @@
 //
 // @author Daniel Willkomm
 //
-message TransmComplete
+packet TransmComplete
 {
 }
Index: src/linklayer/mfcore/BasicDecider.cc
===================================================================
--- src/linklayer/mfcore/BasicDecider.cc	(revision 2038)
+++ src/linklayer/mfcore/BasicDecider.cc	(working copy)
@@ -93,7 +93,7 @@
 void BasicDecider::sendUp(AirFrame * frame)
 {
     numSentUp++;
-    cMessage *macMsg = frame->decapsulate();
+    cPacket *macMsg = frame->decapsulate();
     send(macMsg, uppergateOut);
     coreEV << "sending up msg " << frame->getName() << endl;
     delete frame;
Index: src/linklayer/mfcore/AirFrame.msg
===================================================================
--- src/linklayer/mfcore/AirFrame.msg	(revision 2038)
+++ src/linklayer/mfcore/AirFrame.msg	(working copy)
@@ -45,7 +45,7 @@
 // the id with a pointer to the nodes coordinates itself.
 // @author Marc Loebbers
 //
-message AirFrame
+packet AirFrame
 {
     double pSend; // Power with which this packet is transmitted
     int channelNumber; // Channel on which the packet is sent
Index: src/linklayer/mfcore/WirelessMacBase.cc
===================================================================
--- src/linklayer/mfcore/WirelessMacBase.cc	(revision 2038)
+++ src/linklayer/mfcore/WirelessMacBase.cc	(working copy)
@@ -43,11 +43,11 @@
 void WirelessMacBase::handleMessage(cMessage *msg)
 {
     if (msg->getArrivalGateId()==uppergateIn)
-        handleUpperMsg(msg);
+        handleUpperMsg(PK(msg));
     else if (msg->isSelfMessage())
         handleSelfMsg(msg);
     else
-        handleLowerMsg(msg);
+        handleLowerMsg(PK(msg));
 }
 
 bool WirelessMacBase::isUpperMsg(cMessage *msg)
Index: src/linklayer/contract/TxNotifDetails.h
===================================================================
--- src/linklayer/contract/TxNotifDetails.h	(revision 2038)
+++ src/linklayer/contract/TxNotifDetails.h	(working copy)
@@ -32,15 +32,15 @@
 class TxNotifDetails : public cPolymorphic
 {
   protected:
-    cMessage *msg;
+    cPacket *msg;
     InterfaceEntry *ie;
 
   public:
     TxNotifDetails() {msg=NULL; ie=NULL;}
 
-    cMessage *getMessage() const {return msg;}
+    cPacket *getPacket() const {return msg;}
     InterfaceEntry *getInterfaceEntry() const {return ie;}
-    void setMessage(cMessage *m) {msg = m;}
+    void setPacket(cPacket *m) {msg = m;}
     void setInterfaceEntry(InterfaceEntry *e) {ie = e;}
 };
 
Index: src/linklayer/ethernet/EtherLLC.cc
===================================================================
--- src/linklayer/ethernet/EtherLLC.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherLLC.cc	(working copy)
@@ -41,7 +41,7 @@
     {
       case IEEE802CTRL_DATA:
         // data received from higher layer
-        processPacketFromHigherLayer(msg);
+        processPacketFromHigherLayer(PK(msg));
         break;
 
       case ETH_FRAME:
@@ -84,7 +84,7 @@
     getDisplayString().setTagArg("t",0,buf);
 }
 
-void EtherLLC::processPacketFromHigherLayer(cMessage *msg)
+void EtherLLC::processPacketFromHigherLayer(cPacket *msg)
 {
     if (msg->getByteLength() > (MAX_ETHERNET_DATA-ETHER_LLC_HEADER_LENGTH))
         error("packet from higher layer (%d bytes) plus LLC header exceed maximum Ethernet payload length (%d)", msg->getByteLength(), MAX_ETHERNET_DATA);
@@ -133,7 +133,7 @@
         return;
     }
 
-    cMessage *higherlayermsg = frame->decapsulate();
+    cPacket *higherlayermsg = frame->decapsulate();
 
     Ieee802Ctrl *etherctrl = new Ieee802Ctrl();
     etherctrl->setSsap(frame->getSsap());
Index: src/linklayer/ethernet/EtherLLC.h
===================================================================
--- src/linklayer/ethernet/EtherLLC.h	(revision 2038)
+++ src/linklayer/ethernet/EtherLLC.h	(working copy)
@@ -44,7 +44,7 @@
     virtual void handleMessage(cMessage *msg);
     virtual void finish();
 
-    virtual void processPacketFromHigherLayer(cMessage *msg);
+    virtual void processPacketFromHigherLayer(cPacket *msg);
     virtual void processFrameFromMAC(EtherFrameWithLLC *msg);
     virtual void handleRegisterSAP(cMessage *msg);
     virtual void handleDeregisterSAP(cMessage *msg);
Index: src/linklayer/ethernet/EtherMAC2.cc
===================================================================
--- src/linklayer/ethernet/EtherMAC2.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherMAC2.cc	(working copy)
@@ -51,7 +51,7 @@
         // that the other end is an EtherMAC2, since normal EtherMAC
         // insists that the connection has *no* datarate set.
         // if we're connected, get the gate with transmission rate
-        cChannel *datarateChannel = physOutGate->getDatarateChannel();
+        cChannel *datarateChannel = physOutGate->getTransmissionChannel();
         txrate = datarateChannel->par("datarate").doubleValue();
     }
 }
@@ -99,7 +99,7 @@
     if (hasSubscribers)
     {
         // fire notification
-        notifDetails.setMessage(frame);
+        notifDetails.setPacket(frame);
         nb->fireChangeNotification(NF_PP_TX_BEGIN, &notifDetails);
     }
 
@@ -128,7 +128,7 @@
         startFrameTransmission();
 }
 
-void EtherMAC2::processMsgFromNetwork(cMessage *msg)
+void EtherMAC2::processMsgFromNetwork(cPacket *msg)
 {
     EtherMACBase::processMsgFromNetwork(msg);
     EtherFrame *frame = check_and_cast<EtherFrame *>(msg);
@@ -136,7 +136,7 @@
     if (hasSubscribers)
     {
         // fire notification
-        notifDetails.setMessage(frame);
+        notifDetails.setPacket(frame);
         nb->fireChangeNotification(NF_PP_RX_END, &notifDetails);
     }
 
@@ -156,7 +156,7 @@
     if (hasSubscribers)
     {
         // fire notification
-        notifDetails.setMessage((cMessage *)txQueue.front());
+        notifDetails.setPacket((cPacket *)txQueue.front());
         nb->fireChangeNotification(NF_PP_TX_END, &notifDetails);
     }
 
Index: src/linklayer/ethernet/EtherMAC2.h
===================================================================
--- src/linklayer/ethernet/EtherMAC2.h	(revision 2038)
+++ src/linklayer/ethernet/EtherMAC2.h	(working copy)
@@ -43,7 +43,7 @@
     // event handlers
     virtual void startFrameTransmission();
     virtual void processFrameFromUpperLayer(EtherFrame *frame);
-    virtual void processMsgFromNetwork(cMessage *msg);
+    virtual void processMsgFromNetwork(cPacket *msg);
     virtual void handleEndIFGPeriod();
     virtual void handleEndTxPeriod();
 
Index: src/linklayer/ethernet/EtherEncap.cc
===================================================================
--- src/linklayer/ethernet/EtherEncap.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherEncap.cc	(working copy)
@@ -51,7 +51,7 @@
         {
             case IEEE802CTRL_DATA:
             case 0: // default message kind (0) is also accepted
-              processPacketFromHigherLayer(msg);
+              processPacketFromHigherLayer(PK(msg));
               break;
 
             case IEEE802CTRL_SENDPAUSE:
@@ -75,7 +75,7 @@
     getDisplayString().setTagArg("t",0,buf);
 }
 
-void EtherEncap::processPacketFromHigherLayer(cMessage *msg)
+void EtherEncap::processPacketFromHigherLayer(cPacket *msg)
 {
     if (msg->getByteLength() > MAX_ETHERNET_DATA)
         error("packet from higher layer (%d bytes) exceeds maximum Ethernet payload length (%d)", msg->getByteLength(), MAX_ETHERNET_DATA);
@@ -109,7 +109,7 @@
     totalFromMAC++;
 
     // decapsulate and attach control info
-    cMessage *higherlayermsg = frame->decapsulate();
+    cPacket *higherlayermsg = frame->decapsulate();
 
     // add Ieee802Ctrl to packet
     Ieee802Ctrl *etherctrl = new Ieee802Ctrl();
Index: src/linklayer/ethernet/EtherEncap.h
===================================================================
--- src/linklayer/ethernet/EtherEncap.h	(revision 2038)
+++ src/linklayer/ethernet/EtherEncap.h	(working copy)
@@ -41,7 +41,7 @@
     virtual void handleMessage(cMessage *msg);
     virtual void finish();
 
-    virtual void processPacketFromHigherLayer(cMessage *msg);
+    virtual void processPacketFromHigherLayer(cPacket *msg);
     virtual void processFrameFromMAC(EtherFrame *msg);
     virtual void handleSendPause(cMessage *msg);
 
Index: src/linklayer/ethernet/EtherBus.cc
===================================================================
--- src/linklayer/ethernet/EtherBus.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherBus.cc	(working copy)
@@ -1,3 +1,4 @@
+#if 0 //XXX
 /*
  * Copyright (C) 2003 CTIE, Monash University
  *
@@ -159,7 +160,7 @@
 
         // send out on gate
         bool isLast = (direction==UPSTREAM) ? (tapPoint==0) : (tapPoint==taps-1);
-        cMessage *msg2 = isLast ? msg->decapsulate() : (cMessage *)msg->getEncapsulatedMsg()->dup();
+        cPacket *msg2 = isLast ? msg->decapsulate() : (cMessage *)msg->getEncapsulatedMsg()->dup();
         send(msg2, "ethg$o", tapPoint);
 
         // if not end of the bus, schedule for next tap
@@ -201,4 +202,4 @@
         recordScalar("messages/sec", numMessages/t);
 }
 
-
+#endif 0 //XXX
Index: src/linklayer/ethernet/EtherFrame.msg
===================================================================
--- src/linklayer/ethernet/EtherFrame.msg	(revision 2038)
+++ src/linklayer/ethernet/EtherFrame.msg	(working copy)
@@ -52,7 +52,7 @@
 //  - payload: stored a encapsulated packet (cMessage::encapsulate())
 //  - crc: represented by cMessage::hasBitError()
 //
-message EtherFrame
+packet EtherFrame
 {
     MACAddress dest;
     MACAddress src;
@@ -66,7 +66,7 @@
 //
 // Header length: src(6)+dest(6)+etherType(2) = 14 bytes
 //
-message EthernetIIFrame extends EtherFrame
+packet EthernetIIFrame extends EtherFrame
 {
     int etherType;
 }
@@ -77,7 +77,7 @@
 //
 // Header length: src(6)+dest(6)+length(2)+ssap(1)+dsap(1)+control(1) = 17 bytes
 //
-message EtherFrameWithLLC extends EtherFrame
+packet EtherFrameWithLLC extends EtherFrame
 {
     int ssap;
     int dsap;
@@ -94,7 +94,7 @@
 // Header length: src(6)+dest(6)+length(2)+ssap(1)+dsap(1)+control(1)+
 // orgCode(3)+localCode(2) = 22 bytes
 //
-message EtherFrameWithSNAP extends EtherFrame
+packet EtherFrameWithSNAP extends EtherFrame
 {
     long orgCode;  // SNAP organization code, 0 for IP and ARP
     int localcode; // SNAP local code (stores EtherType for IP and ARP)
@@ -104,7 +104,7 @@
 //
 // Ethernet frame used by the PAUSE protocol
 //
-message EtherPauseFrame extends EtherFrame
+packet EtherPauseFrame extends EtherFrame
 {
     int pauseTime; // in 512 bit-time units
 }
@@ -126,7 +126,7 @@
 //   send true. Duplex operation only chosen by a MAC if nobody vetoed it by sending
 //   halfDuplex=true.
 //
-message EtherAutoconfig
+packet EtherAutoconfig
 {
     double txrate = 0;
     bool halfDuplex = false;
Index: src/linklayer/ethernet/EtherMACBase.cc
===================================================================
--- src/linklayer/ethernet/EtherMACBase.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherMACBase.cc	(working copy)
@@ -124,7 +124,7 @@
 void EtherMACBase::initializeFlags()
 {
     // initialize connected flag
-    connected = physOutGate->getDestinationGate()->isConnected();
+    connected = physOutGate->getPathEndGate()->isConnected();
     if (!connected)
         EV << "MAC not connected to a network.\n";
     WATCH(connected);
@@ -337,7 +337,7 @@
 
 }
 
-void EtherMACBase::processMsgFromNetwork(cMessage *frame)
+void EtherMACBase::processMsgFromNetwork(cPacket *frame)
 {
     EV << "Received frame from network: " << frame << endl;
 
@@ -439,7 +439,7 @@
         error("End of IFG and no frame to transmit");
 
     // End of IFG period, okay to transmit, if Rx idle OR duplexMode
-    cMessage *frame = (cMessage *)txQueue.front();
+    cPacket *frame = (cPacket *)txQueue.front();
     EV << "IFG elapsed, now begin transmission of frame " << frame << endl;
 
     // Perform carrier extension if in Gigabit Ethernet
@@ -468,7 +468,7 @@
         error("Frame under transmission cannot be found");
 
     // get frame from buffer
-    cMessage *frame = (cMessage*)txQueue.pop();
+    cPacket *frame = (cPacket *)txQueue.pop();
 
     numFramesSent++;
     numBytesSent += frame->getByteLength();
@@ -512,7 +512,7 @@
     transmitState = WAIT_IFG_STATE;
 }
 
-void EtherMACBase::scheduleEndTxPeriod(cMessage *frame)
+void EtherMACBase::scheduleEndTxPeriod(cPacket *frame)
 {
     scheduleAt(simTime()+frame->getBitLength()*bitTime, endTxMsg);
     transmitState = TRANSMITTING_STATE;
@@ -566,10 +566,10 @@
     }
 }
 
-void EtherMACBase::fireChangeNotification(int type, cMessage *msg)
+void EtherMACBase::fireChangeNotification(int type, cPacket *msg)
 {
     if (nb) {
-        notifDetails.setMessage(msg);
+        notifDetails.setPacket(msg);
         nb->fireChangeNotification(type, &notifDetails);
     }
 }
@@ -671,7 +671,7 @@
     {
         g->getDisplayString().setTagArg("o",0,color);
         g->getDisplayString().setTagArg("o",1, color[0] ? "3" : "1");
-        g = g->getToGate();
+        g = g->getNextGate();
     }
 }
 
Index: src/linklayer/ethernet/EtherMACBase.h
===================================================================
--- src/linklayer/ethernet/EtherMACBase.h	(revision 2038)
+++ src/linklayer/ethernet/EtherMACBase.h	(working copy)
@@ -152,19 +152,19 @@
 
     // event handlers
     virtual void processFrameFromUpperLayer(EtherFrame *msg);
-    virtual void processMsgFromNetwork(cMessage *msg);
+    virtual void processMsgFromNetwork(cPacket *msg);
     virtual void processMessageWhenNotConnected(cMessage *msg);
     virtual void processMessageWhenDisabled(cMessage *msg);
     virtual void handleEndIFGPeriod();
     virtual void handleEndTxPeriod();
     virtual void handleEndPausePeriod();
     virtual void scheduleEndIFGPeriod();
-    virtual void scheduleEndTxPeriod(cMessage*);
+    virtual void scheduleEndTxPeriod(cPacket *);
     virtual void scheduleEndPausePeriod(int pauseUnits);
 
     // helpers
     virtual bool checkAndScheduleEndPausePeriod();
-    virtual void fireChangeNotification(int type, cMessage *msg);
+    virtual void fireChangeNotification(int type, cPacket *msg);
     virtual void beginSendFrames();
     virtual void frameReceptionComplete(EtherFrame *frame);
     virtual void processReceivedDataFrame(EtherFrame *frame);
Index: src/linklayer/ethernet/EtherMAC.cc
===================================================================
--- src/linklayer/ethernet/EtherMAC.cc	(revision 2038)
+++ src/linklayer/ethernet/EtherMAC.cc	(working copy)
@@ -65,7 +65,7 @@
             error("connection on gate %s has data rate set: using data rate with EtherMAC "
                   "is forbidden, module's txrate parameter must be used instead",
                   g->getFullPath().c_str());
-        g = g->getToGate();
+        g = g->getNextGate();
     }
 
     // launch autoconfig process
@@ -225,7 +225,7 @@
         if (msg->getArrivalGate() == gate("upperLayerIn"))
             processFrameFromUpperLayer(check_and_cast<EtherFrame *>(msg));
         else
-            processMsgFromNetwork(msg);
+            processMsgFromNetwork(PK(msg));
     }
     else
     {
@@ -280,7 +280,7 @@
 }
 
 
-void EtherMAC::processMsgFromNetwork(cMessage *msg)
+void EtherMAC::processMsgFromNetwork(cPacket *msg)
 {
     EtherMACBase::processMsgFromNetwork(msg);
 
@@ -397,7 +397,7 @@
     EtherMACBase::handleEndIFGPeriod();
 
     // End of IFG period, okay to transmit, if Rx idle OR duplexMode
-    cMessage *frame = (cMessage *)txQueue.front();
+    cPacket *frame = (cPacket *)txQueue.front();
 
     // Perform carrier extension if in Gigabit Ethernet
     if (carrierExtension && frame->getByteLength() < GIGABIT_MIN_FRAME_WITH_EXT)
@@ -412,9 +412,9 @@
 
 void EtherMAC::startFrameTransmission()
 {
-    cMessage *origFrame = (cMessage *)txQueue.front();
+    cPacket *origFrame = (cPacket *)txQueue.front();
     EV << "Transmitting a copy of frame " << origFrame << endl;
-    cMessage *frame = (cMessage *) origFrame->dup();
+    cPacket *frame = origFrame->dup();
 
     // add preamble and SFD (Starting Frame Delimiter), then send out
     frame->addByteLength(PREAMBLE_BYTES+SFD_BYTES);
@@ -558,7 +558,7 @@
 
 void EtherMAC::sendJamSignal()
 {
-    cMessage *jam = new cMessage("JAM_SIGNAL", JAM_SIGNAL);
+    cPacket *jam = new cPacket("JAM_SIGNAL", JAM_SIGNAL);
     jam->setByteLength(JAM_SIGNAL_BYTES);
     if (ev.isGUI())  updateConnectionColor(JAMMING_STATE);
     send(jam, physOutGate);
@@ -567,7 +567,7 @@
     transmitState = JAMMING_STATE;
 }
 
-void EtherMAC::scheduleEndRxPeriod(cMessage *frame)
+void EtherMAC::scheduleEndRxPeriod(cPacket *frame)
 {
     scheduleAt(simTime()+frame->getBitLength()*bitTime, endRxMsg);
     receiveState = RECEIVING_STATE;
Index: src/linklayer/ethernet/EtherMAC.h
===================================================================
--- src/linklayer/ethernet/EtherMAC.h	(revision 2038)
+++ src/linklayer/ethernet/EtherMAC.h	(working copy)
@@ -72,7 +72,7 @@
 
     // event handlers
     virtual void processFrameFromUpperLayer(EtherFrame *msg);
-    virtual void processMsgFromNetwork(cMessage *msg);
+    virtual void processMsgFromNetwork(cPacket *msg);
     virtual void handleEndIFGPeriod();
     virtual void handleEndTxPeriod();
     virtual void handleEndRxPeriod();
@@ -85,7 +85,7 @@
     virtual void printState();
 
     // helpers
-    virtual void scheduleEndRxPeriod(cMessage*);
+    virtual void scheduleEndRxPeriod(cPacket *);
     virtual void sendJamSignal();
     virtual void handleRetransmission();
     virtual void startFrameTransmission();
Index: src/linklayer/mf80211/macLayer/Mac80211.cc
===================================================================
--- src/linklayer/mf80211/macLayer/Mac80211.cc	(revision 2038)
+++ src/linklayer/mf80211/macLayer/Mac80211.cc	(working copy)
@@ -1,7 +1,7 @@
 /***************************************************************************
  * file:        Mac80211.cc
  *
- * author:      David Raguin / Marc Lbbers
+ * author:      David Raguin / Marc Lbbers
  *
  * copyright:   (C) 2004 Telecommunication Networks Group (TKN) at
  *              Technische Universitaet Berlin, Germany.
@@ -134,7 +134,7 @@
  * This implementation does not support fragmentation, so it is tested
  * if the maximum length of the MPDU is exceeded.
  */
-void Mac80211::handleUpperMsg(cMessage *msg)
+void Mac80211::handleUpperMsg(cPacket *msg)
 {
     if (msg->getByteLength() > 2312)
         error("packet from higher layer (%s)%s is too long for 802.11b, %d bytes (fragmentation is not supported yet)",
@@ -167,7 +167,7 @@
  * Encapsulates the received network-layer packet into a MacPkt and set all needed
  * header fields.
  */
-Mac80211Pkt *Mac80211::encapsMsg(cMessage * netw)
+Mac80211Pkt *Mac80211::encapsMsg(cPacket *netw)
 {
     Mac80211Pkt *pkt = new Mac80211Pkt(netw->getName());
     pkt->setBitLength(272);        // headerLength, including final CRC-field
@@ -188,7 +188,7 @@
 
 void Mac80211::decapsulateAndSendUp(Mac80211Pkt *frame)
 {
-    cMessage *msg = frame->decapsulate();
+    cPacket *msg = frame->decapsulate();
     // FIXME TBD set control info
     delete frame;
     sendUp(msg);
@@ -200,7 +200,7 @@
  *  handleMsgNotForMe(), handleBroadcastMsg(), or handleMsgForMe().
  *  Called by handleMessage().
  */
-void Mac80211::handleLowerMsg(cMessage *msg)
+void Mac80211::handleLowerMsg(cPacket *msg)
 {
     Mac80211Pkt *af = check_and_cast<Mac80211Pkt *>(msg);
 
Index: src/linklayer/mf80211/macLayer/Mac80211Pkt.msg
===================================================================
--- src/linklayer/mf80211/macLayer/Mac80211Pkt.msg	(revision 2038)
+++ src/linklayer/mf80211/macLayer/Mac80211Pkt.msg	(working copy)
@@ -23,7 +23,7 @@
 //
 // This component has been taken over from Mobility Framework 1.0a5.
 //
-message Mac80211Pkt extends MacPkt
+packet Mac80211Pkt extends MacPkt
 {
     int address3;
     int address4;
Index: src/linklayer/mf80211/macLayer/Mac80211.h
===================================================================
--- src/linklayer/mf80211/macLayer/Mac80211.h	(revision 2038)
+++ src/linklayer/mf80211/macLayer/Mac80211.h	(working copy)
@@ -1,7 +1,7 @@
 /* -*- mode:c++ -*- ********************************************************
  * file:        Mac80211.h
  *
- * author:      David Raguin/Marc Lbbers
+ * author:      David Raguin/Marc Lbbers
  *
  * copyright:   (C) 2004 Telecommunication Networks Group (TKN) at
  *              Technische Universitaet Berlin, Germany.
@@ -81,10 +81,10 @@
     virtual void handleSelfMsg(cMessage*);
 
     /** @brief Handle messages from upper layer */
-    virtual void handleUpperMsg(cMessage*);
+    virtual void handleUpperMsg(cPacket*);
 
     /** @brief Handle messages from lower layer */
-    virtual void handleLowerMsg(cMessage*);
+    virtual void handleLowerMsg(cPacket*);
 
     /** @brief handle end of contention */
     virtual void handleEndContentionTimer();
@@ -130,7 +130,7 @@
     virtual void sendBROADCASTframe();
 
     /** @brief encapsulate packet */
-    virtual Mac80211Pkt* encapsMsg(cMessage *netw);
+    virtual Mac80211Pkt* encapsMsg(cPacket *netw);
 
     /** @brief decapsulate packet and send to higher layer */
     virtual void decapsulateAndSendUp(Mac80211Pkt *frame);
Index: src/linklayer/mf80211/macLayer/MacPkt.msg
===================================================================
--- src/linklayer/mf80211/macLayer/MacPkt.msg	(revision 2038)
+++ src/linklayer/mf80211/macLayer/MacPkt.msg	(working copy)
@@ -38,7 +38,7 @@
 //
 //# FIXME just temporary here
 //
-message MacPkt
+packet MacPkt
 {
     MACAddress destAddr; // destination mac address
     MACAddress srcAddr; // source mac address
Index: src/linklayer/mf80211/macLayer/CSMAMacLayer.cc
===================================================================
--- src/linklayer/mf80211/macLayer/CSMAMacLayer.cc	(revision 2038)
+++ src/linklayer/mf80211/macLayer/CSMAMacLayer.cc	(working copy)
@@ -124,7 +124,7 @@
  *
  * If channel is idle the frame will be transmitted immediately.
  */
-void CSMAMacLayer::handleUpperMsg(cMessage *msg)
+void CSMAMacLayer::handleUpperMsg(cPacket *msg)
 {
     MacPkt *mac = encapsMsg(msg);
 
@@ -205,7 +205,7 @@
  * frame. If they are equal or the frame is broadcast, we send this
  * frame to the upper layer. If not delete it.
  */
-void CSMAMacLayer::handleLowerMsg(cMessage *msg)
+void CSMAMacLayer::handleLowerMsg(cPacket *msg)
 {
     MacPkt *mac = check_and_cast<MacPkt *>(msg);
 
@@ -226,7 +226,7 @@
  * Encapsulates the received network-layer packet into a MacPkt and set all needed
  * header fields.
  */
-MacPkt *CSMAMacLayer::encapsMsg(cMessage *netw)
+MacPkt *CSMAMacLayer::encapsMsg(cPacket *netw)
 {
     MacPkt *pkt = new MacPkt(netw->getName());
     pkt->setBitLength(272);
Index: src/linklayer/mf80211/macLayer/CSMAMacLayer.h
===================================================================
--- src/linklayer/mf80211/macLayer/CSMAMacLayer.h	(revision 2038)
+++ src/linklayer/mf80211/macLayer/CSMAMacLayer.h	(working copy)
@@ -66,7 +66,7 @@
  * The TestApplLayer e.g. implements such a processing delay!
  *
  * @ingroup macLayer
- * @author Marc Lbbers, Yosia Hadisusanto
+ * @author Marc Lbbers, Yosia Hadisusanto
  */
 class INET_API CSMAMacLayer : public WirelessMacBase, public INotifiable
 {
@@ -85,16 +85,16 @@
     virtual void finish();
 
     /** @brief Handle messages from lower layer */
-    virtual void handleLowerMsg(cMessage*);
+    virtual void handleLowerMsg(cPacket*);
 
     /** @brief Handle messages from upper layer */
-    virtual void handleUpperMsg(cMessage*);
+    virtual void handleUpperMsg(cPacket*);
 
     /** @brief Handle self messages such as timers */
     virtual void handleSelfMsg(cMessage*);
 
     /** @brief Encapsulate the given higher-layer packet into MacPkt */
-    virtual MacPkt *encapsMsg(cMessage *netw);
+    virtual MacPkt *encapsMsg(cPacket *netw);
 
     /** @brief Called by the NotificationBoard whenever a change occurs we're interested in */
     virtual void receiveChangeNotification(int category, const cPolymorphic *details);
Index: src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.cc
===================================================================
--- src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.cc	(revision 2038)
+++ src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.cc	(working copy)
@@ -36,7 +36,7 @@
  * different bitrates of header and data. The header is sent with
  * 1Mbit/s and the rest with the bitrate read in in initialize().
  */
-double SnrEval80211::calcDuration(cMessage * frame)
+double SnrEval80211::calcDuration(cPacket *frame)
 {
     EV << "bits without header: " << frame->getBitLength() -
         headerLength << ", bits header: " << headerLength << endl;
Index: src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.h
===================================================================
--- src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.h	(revision 2038)
+++ src/linklayer/mf80211/phyLayer/snrEval/SnrEval80211.h	(working copy)
@@ -45,7 +45,7 @@
 
   protected:
     /** @brief computes the duration of a 802.11 frame in seconds */
-    virtual double calcDuration(cMessage*);
+    virtual double calcDuration(cPacket *);
 };
 
 #endif
Index: src/linklayer/mf80211/phyLayer/snrEval/SnrEval.cc
===================================================================
--- src/linklayer/mf80211/phyLayer/snrEval/SnrEval.cc	(revision 2038)
+++ src/linklayer/mf80211/phyLayer/snrEval/SnrEval.cc	(working copy)
@@ -99,7 +99,7 @@
 
 void SnrEval::handleMessage(cMessage *msg)
 {
-    if (msg->getArrivalGateId()==uppergateIn && msg->getBitLength()==0)
+    if (msg->getArrivalGateId()==uppergateIn /*FIXME TODO: "AND NOT PACKET"! && msg->getBitLength()==0 */ )
     {
         cPolymorphic *ctrl = msg->removeControlInfo();
         handleCommand(msg->getKind(), ctrl);
Index: src/linklayer/radio/Ieee80211RadioModel.cc
===================================================================
--- src/linklayer/radio/Ieee80211RadioModel.cc	(revision 2038)
+++ src/linklayer/radio/Ieee80211RadioModel.cc	(working copy)
@@ -46,7 +46,7 @@
         if (iter->snr < snirMin)
             snirMin = iter->snr;
 
-    cMessage *frame = airframe->getEncapsulatedMsg();
+    cPacket *frame = airframe->getEncapsulatedMsg();
     EV << "packet (" << frame->getClassName() << ")" << frame->getName() << " (" << frame->info() << ") snrMin=" << snirMin << endl;
 
     if (snirMin <= snirThreshold)
Index: src/linklayer/radio/AbstractRadio.cc
===================================================================
--- src/linklayer/radio/AbstractRadio.cc	(revision 2038)
+++ src/linklayer/radio/AbstractRadio.cc	(working copy)
@@ -132,7 +132,7 @@
 void AbstractRadio::handleMessage(cMessage *msg)
 {
     // handle commands
-    if (msg->getArrivalGateId()==uppergateIn && msg->getBitLength()==0)
+    if (msg->getArrivalGateId()==uppergateIn && !msg->isPacket() /*FIXME XXX ENSURE REALLY PLAIN cMessage ARE SENT AS COMMANDS!!! && msg->getBitLength()==0*/)
     {
         cPolymorphic *ctrl = msg->removeControlInfo();
         if (msg->getKind()==0)
@@ -144,7 +144,7 @@
 
     if (msg->getArrivalGateId() == uppergateIn)
     {
-        AirFrame *airframe = encapsulatePacket(msg);
+        AirFrame *airframe = encapsulatePacket(PK(msg));
         handleUpperMsg(airframe);
     }
     else if (msg->isSelfMessage())
@@ -184,7 +184,7 @@
     scheduleAt(airframe->getArrivalTime() + airframe->getDuration(), endRxTimer);
 }
 
-AirFrame *AbstractRadio::encapsulatePacket(cMessage *frame)
+AirFrame *AbstractRadio::encapsulatePacket(cPacket *frame)
 {
     PhyControlInfo *ctrl = dynamic_cast<PhyControlInfo *>(frame->removeControlInfo());
     ASSERT(!ctrl || ctrl->getChannelNumber()==-1); // per-packet channel switching not supported
@@ -207,7 +207,7 @@
 
 void AbstractRadio::sendUp(AirFrame *airframe)
 {
-    cMessage *frame = airframe->decapsulate();
+    cPacket *frame = airframe->decapsulate();
     delete airframe;
     EV << "sending up frame " << frame->getName() << endl;
     send(frame, uppergateOut);
@@ -594,14 +594,14 @@
 
                  // we need to send to each radioIn[] gate of this host
                  for (int i = 0; i < radioGate->size(); i++)
-                     sendDirect((cMessage*)airframe->dup(), airframe->getTimestamp() + propagationDelay - simTime(), airframe->getDuration(), myHost, radioGate->getId() + i);
+                     sendDirect(airframe->dup(), airframe->getTimestamp() + propagationDelay - simTime(), airframe->getDuration(), myHost, radioGate->getId() + i);
             }
             // if we hear some part of the message
             else if (airframe->getTimestamp() + airframe->getDuration() + propagationDelay > simTime())
             {
                  EV << "missed beginning of frame, processing it as noise\n";
 
-                 AirFrame *frameDup = (AirFrame*)airframe->dup();
+                 AirFrame *frameDup = airframe->dup();
                  frameDup->setArrivalTime(airframe->getTimestamp() + propagationDelay);
                  handleLowerMsgStart(frameDup);
                  bufferMsg(frameDup);
Index: src/linklayer/radio/AbstractRadio.h
===================================================================
--- src/linklayer/radio/AbstractRadio.h	(revision 2038)
+++ src/linklayer/radio/AbstractRadio.h	(working copy)
@@ -91,7 +91,7 @@
     virtual void sendDown(AirFrame *airframe);
 
     /** Encapsulates a MAC frame into an Air Frame */
-    virtual AirFrame *encapsulatePacket(cMessage *msg);
+    virtual AirFrame *encapsulatePacket(cPacket *msg);
 
     /** Sets the radio state, and also fires change notification */
     virtual void setRadioState(RadioState::State newState);
Index: src/transport/rtp/RTPInnerPacket.h
===================================================================
--- src/transport/rtp/RTPInnerPacket.h	(revision 2038)
+++ src/transport/rtp/RTPInnerPacket.h	(working copy)
@@ -32,7 +32,7 @@
 /**
  * This class is used for communication between submodules of the rtp layer module.
  */
-class INET_API RTPInnerPacket : public cMessage
+class INET_API RTPInnerPacket : public cPacket
 {
 
     public:
Index: src/transport/rtp/profiles/avprofile/RTPAVProfilePayload32Sender.cc
===================================================================
--- src/transport/rtp/profiles/avprofile/RTPAVProfilePayload32Sender.cc	(revision 2038)
+++ src/transport/rtp/profiles/avprofile/RTPAVProfilePayload32Sender.cc	(working copy)
@@ -142,7 +142,7 @@
     _initialDelay = delay;
 
     // wait initial delay
-    // cMessage *reminderMessage = new cMessage("next frame");
+    // cPacket *reminderMessage = new cMessage("next frame");
     // scheduleAt(simTime() + _initialDelay, reminderMessage);
     ev << "initializeSenderModule Exit"<<endl;
 };
Index: src/transport/rtp/profiles/avprofile/RTPMpegPacket.msg
===================================================================
--- src/transport/rtp/profiles/avprofile/RTPMpegPacket.msg	(revision 2038)
+++ src/transport/rtp/profiles/avprofile/RTPMpegPacket.msg	(working copy)
@@ -35,7 +35,7 @@
 // @see RTPAVProfilePayload32Sender
 // @see RTPAVProfilePayload32Receiver
 //
-message RTPMpegPacket
+packet RTPMpegPacket
 {
     int headerLength = 4;
     int payloadLength; // size of the mpeg data
Index: src/transport/rtp/RTCPPacket.h
===================================================================
--- src/transport/rtp/RTCPPacket.h	(revision 2038)
+++ src/transport/rtp/RTCPPacket.h	(working copy)
@@ -41,7 +41,7 @@
  * This is a base class for all types (except RTCPCompoundPacket) of rtcp
  * packets. It isn't intended to be used directly.
  */
-class INET_API RTCPPacket : public cMessage
+class INET_API RTCPPacket : public cPacket
 {
     public:
 
@@ -118,7 +118,7 @@
         /**
          * Returns the value of the field length in the rtcp header.
          * The value isn't stored because it can be calculated
-         * with the getLength() method inherited from cMessage.
+         * with the getLength() method inherited from cPacket.
          */
         virtual int getRtcpLength() const;
 
@@ -428,7 +428,7 @@
  * one RTCPSDESPacket. This class doesn't check if these requirements are
  * met.
  */
-class INET_API RTCPCompoundPacket : public cMessage
+class INET_API RTCPCompoundPacket : public cPacket
 {
 
     public:
Index: src/transport/rtp/RTP.cc
===================================================================
--- src/transport/rtp/RTP.cc	(revision 2038)
+++ src/transport/rtp/RTP.cc	(working copy)
@@ -168,7 +168,7 @@
 
 void RTP::leaveSession(RTPInterfacePacket *rifp)
 {
-    cModule *profileModule = gate("toProfile")->getToGate()->getOwnerModule();
+    cModule *profileModule = gate("toProfile")->getNextGate()->getOwnerModule();
     profileModule->deleteModule();
     _leaveSession = true;
     RTPInnerPacket *rinp = new RTPInnerPacket("leaveSession()");
Index: src/transport/rtp/RTCP.cc
===================================================================
--- src/transport/rtp/RTCP.cc	(revision 2038)
+++ src/transport/rtp/RTCP.cc	(working copy)
@@ -104,7 +104,7 @@
 
 void RTCP::handleMessageFromUDP(cMessage *msg) {
     // from SocketLayer all message are of type cMessage
-    readRet(msg);
+    readRet(PK(msg));
 };
 
 
@@ -186,7 +186,7 @@
 };
 
 
-void RTCP::readRet(cMessage *sifpIn)
+void RTCP::readRet(cPacket *sifpIn)
 {
     RTCPCompoundPacket *packet = (RTCPCompoundPacket *)(sifpIn->decapsulate());
     processIncomingRTCPPacket(packet, IPAddress(_destinationAddress), _port);
@@ -313,7 +313,7 @@
 
     calculateAveragePacketSize(compoundPacket->getByteLength());
 
-    cMessage *msg = new cMessage("RTCPCompoundPacket");
+    cPacket *msg = new cPacket("RTCPCompoundPacket");
     msg->encapsulate(compoundPacket);
     msg->setKind(UDP_C_DATA);
     UDPControlInfo *ctrl = new UDPControlInfo();
Index: src/transport/rtp/RTPSenderControlMessage.msg
===================================================================
--- src/transport/rtp/RTPSenderControlMessage.msg	(revision 2038)
+++ src/transport/rtp/RTPSenderControlMessage.msg	(working copy)
@@ -38,7 +38,7 @@
 //    - SEEK_TIME : go to temporal position within the file (not allowed while playing)
 //    - SEEK_BYTE : go to data byte (not allowed while playing)
 //
-message RTPSenderControlMessage
+packet RTPSenderControlMessage
 {
     string command;
     float commandParameter1;
Index: src/transport/rtp/RTPInterfacePacket.cc
===================================================================
--- src/transport/rtp/RTPInterfacePacket.cc	(revision 2038)
+++ src/transport/rtp/RTPInterfacePacket.cc	(working copy)
@@ -24,7 +24,7 @@
 Register_Class(RTPInterfacePacket);
 
 
-RTPInterfacePacket::RTPInterfacePacket(const char *name) : cMessage(name) {
+RTPInterfacePacket::RTPInterfacePacket(const char *name) : cPacket(name) {
     _type = RTP_IFP_UNDEF;
     _commonName = NULL;
     _profileName = NULL;
@@ -37,7 +37,7 @@
 };
 
 
-RTPInterfacePacket::RTPInterfacePacket(const RTPInterfacePacket& rifp) : cMessage() {
+RTPInterfacePacket::RTPInterfacePacket(const RTPInterfacePacket& rifp) : cPacket() {
     setName(rifp.getName());
     operator=(rifp);
 };
@@ -54,7 +54,7 @@
 
 
 RTPInterfacePacket& RTPInterfacePacket::operator=(const RTPInterfacePacket& rifp) {
-    cMessage::operator=(rifp);
+    cPacket::operator=(rifp);
     _type = rifp._type;
     _commonName = opp_strdup(rifp._commonName);
     _profileName = opp_strdup(rifp._profileName);
Index: src/transport/rtp/RTPSenderStatusMessage.msg
===================================================================
--- src/transport/rtp/RTPSenderStatusMessage.msg	(revision 2038)
+++ src/transport/rtp/RTPSenderStatusMessage.msg	(working copy)
@@ -30,7 +30,7 @@
 // If a message must provide more information than just a string, a new class
 // defining this parameter can derived.
 //
-message RTPSenderStatusMessage
+packet RTPSenderStatusMessage
 {
     string status;
     uint32 timeStamp;
Index: src/transport/rtp/RTPPacket.cc
===================================================================
--- src/transport/rtp/RTPPacket.cc	(revision 2038)
+++ src/transport/rtp/RTPPacket.cc	(working copy)
@@ -24,7 +24,7 @@
 Register_Class(RTPPacket);
 
 
-RTPPacket::RTPPacket(const char *name) : cMessage(name) {
+RTPPacket::RTPPacket(const char *name) : cPacket(name) {
     _version = 2;
     _padding = 0;
     _extension = 0;
@@ -40,7 +40,7 @@
 };
 
 
-RTPPacket::RTPPacket(const RTPPacket& packet) : cMessage() {
+RTPPacket::RTPPacket(const RTPPacket& packet) : cPacket() {
     setName(packet.getName());
     operator=(packet);
 };
@@ -58,7 +58,7 @@
 
 
 RTPPacket& RTPPacket::operator=(const RTPPacket& packet) {
-    cMessage::operator=(packet);
+    cPacket::operator=(packet);
     _version = packet._version;
     _padding = packet._padding;
     _extension = packet._extension;
Index: src/transport/rtp/RTPPacket.h
===================================================================
--- src/transport/rtp/RTPPacket.h	(revision 2038)
+++ src/transport/rtp/RTPPacket.h	(working copy)
@@ -31,7 +31,7 @@
  * Following rtp header fields exist but aren't used: padding, extension,
  * csrcCount. The csrcList can't be used because csrcCount is always 0.
  */
-class INET_API RTPPacket : public cMessage
+class INET_API RTPPacket : public cPacket
 {
 
     public:
Index: src/transport/rtp/RTCPPacket.cc
===================================================================
--- src/transport/rtp/RTCPPacket.cc	(revision 2038)
+++ src/transport/rtp/RTCPPacket.cc	(working copy)
@@ -33,13 +33,13 @@
 Register_Class(RTCPPacket);
 
 
-RTCPPacket::RTCPPacket(const char *name) : cMessage(name) {
+RTCPPacket::RTCPPacket(const char *name) : cPacket(name) {
     // initialize variables
     _version = 2;
     _padding = 0;
     _count = 0;
     _packetType = RTCP_PT_UNDEF;
-    // rtcpLength can be calculated with cMessage::getLength()
+    // rtcpLength can be calculated with cPacket::getLength()
 
     // RTCP header length size is 4 bytes
     // not all rtcp packets (in particular RTCPSDESPacket) have
@@ -48,7 +48,7 @@
 };
 
 
-RTCPPacket::RTCPPacket(const RTCPPacket& rtcpPacket) : cMessage() {
+RTCPPacket::RTCPPacket(const RTCPPacket& rtcpPacket) : cPacket() {
     setName(rtcpPacket.getName());
     operator=(rtcpPacket);
 };
@@ -59,7 +59,7 @@
 
 
 RTCPPacket& RTCPPacket::operator=(const RTCPPacket& rtcpPacket) {
-    cMessage::operator=(rtcpPacket);
+    cPacket::operator=(rtcpPacket);
     setName(rtcpPacket.getName());
     _version = rtcpPacket._version;
     _padding = rtcpPacket._padding;
@@ -395,14 +395,14 @@
 Register_Class(RTCPCompoundPacket);
 
 
-RTCPCompoundPacket::RTCPCompoundPacket(const char *name) : cMessage(name) {
+RTCPCompoundPacket::RTCPCompoundPacket(const char *name) : cPacket(name) {
     _rtcpPackets = new cArray("RTCPPackets");
     // an empty rtcp compound packet has length 0 bytes
     setByteLength(0);
 };
 
 
-RTCPCompoundPacket::RTCPCompoundPacket(const RTCPCompoundPacket& rtcpCompoundPacket) : cMessage() {
+RTCPCompoundPacket::RTCPCompoundPacket(const RTCPCompoundPacket& rtcpCompoundPacket) : cPacket() {
     setName(rtcpCompoundPacket.getName());
     operator=(rtcpCompoundPacket);
 };
@@ -414,7 +414,7 @@
 
 
 RTCPCompoundPacket& RTCPCompoundPacket::operator=(const RTCPCompoundPacket& rtcpCompoundPacket) {
-    cMessage::operator=(rtcpCompoundPacket);
+    cPacket::operator=(rtcpCompoundPacket);
     setByteLength(rtcpCompoundPacket.getByteLength());
     _rtcpPackets = new cArray(*(rtcpCompoundPacket._rtcpPackets));
     return *this;
Index: src/transport/rtp/RTCP.h
===================================================================
--- src/transport/rtp/RTCP.h	(revision 2038)
+++ src/transport/rtp/RTCP.h	(working copy)
@@ -103,7 +103,7 @@
          * Called when this rtcp module receives data from the
          * socket layer.
          */
-        virtual void readRet(cMessage *sifpIn);
+        virtual void readRet(cPacket *sifpIn);
 
     protected:
 
Index: src/transport/rtp/RTPInterfacePacket.h
===================================================================
--- src/transport/rtp/RTPInterfacePacket.h	(revision 2038)
+++ src/transport/rtp/RTPInterfacePacket.h	(working copy)
@@ -17,7 +17,7 @@
 
 /** \file RTPInterfacePacket.h
  * This file declares the class RTPInterfacePacket. This class is derived from
- * cMessage and is used for controlling the rtp layer by the rtp application.
+ * cPacket and is used for controlling the rtp layer by the rtp application.
  */
 
 
@@ -37,7 +37,7 @@
  * rtp session, transmission of files and feedback about the success of the
  * operations.
  */
-class INET_API RTPInterfacePacket : public cMessage
+class INET_API RTPInterfacePacket : public cPacket
 {
 
     public:
Index: src/transport/rtp/RTPProfile.cc
===================================================================
--- src/transport/rtp/RTPProfile.cc	(revision 2038)
+++ src/transport/rtp/RTPProfile.cc	(working copy)
@@ -179,8 +179,9 @@
 };
 
 
-void RTPProfile::deleteSenderModule(RTPInnerPacket *rinpIn) {
-    cModule *senderModule = gate("toPayloadSender")->getToGate()->getOwnerModule();
+void RTPProfile::deleteSenderModule(RTPInnerPacket *rinpIn)
+{
+    cModule *senderModule = gate("toPayloadSender")->getNextGate()->getOwnerModule();
     senderModule->deleteModule();
 
     RTPInnerPacket *rinpOut = new RTPInnerPacket("senderModuleDeleted()");
@@ -191,7 +192,8 @@
 };
 
 
-void RTPProfile::senderModuleControl(RTPInnerPacket *rinp) {
+void RTPProfile::senderModuleControl(RTPInnerPacket *rinp)
+{
     send(rinp, "toPayloadSender");
 };
 
@@ -239,7 +241,8 @@
 };
 
 
-void RTPProfile::dataOut(RTPInnerPacket *rinp) {
+void RTPProfile::dataOut(RTPInnerPacket *rinp)
+{
     processOutgoingPacket(rinp);
     send(rinp, "toRTP");
 };
@@ -285,7 +288,8 @@
 };
 
 
-RTPProfile::SSRCGate *RTPProfile::newSSRCGate(uint32 ssrc) {
+RTPProfile::SSRCGate *RTPProfile::newSSRCGate(uint32 ssrc)
+{
     SSRCGate *ssrcGate = new SSRCGate(ssrc);
     bool assigned = false;
     int receiverGateId = findGate("toPayloadReceiver",0);
Index: src/transport/rtp/RTPInnerPacket.cc
===================================================================
--- src/transport/rtp/RTPInnerPacket.cc	(revision 2038)
+++ src/transport/rtp/RTPInnerPacket.cc	(working copy)
@@ -27,7 +27,7 @@
 Register_Class(RTPInnerPacket);
 
 
-RTPInnerPacket::RTPInnerPacket(const char *name) : cMessage(name) {
+RTPInnerPacket::RTPInnerPacket(const char *name) : cPacket(name) {
     _type = RTP_INP_UNDEF;
     _commonName = NULL;
     _mtu = 0;
@@ -44,7 +44,7 @@
 };
 
 
-RTPInnerPacket::RTPInnerPacket(const RTPInnerPacket& rinp) : cMessage() {
+RTPInnerPacket::RTPInnerPacket(const RTPInnerPacket& rinp) : cPacket() {
     setName(rinp.getName());
     operator=(rinp);
 };
@@ -59,7 +59,7 @@
 
 
 RTPInnerPacket& RTPInnerPacket::operator=(const RTPInnerPacket& rinp) {
-    cMessage::operator=(rinp);
+    cPacket::operator=(rinp);
     _type = rinp._type;
     _commonName = opp_strdup(rinp._commonName);
     _mtu = rinp._mtu;
Index: src/transport/tcp/TCPConnectionEventProc.cc
===================================================================
--- src/transport/tcp/TCPConnectionEventProc.cc	(revision 2038)
+++ src/transport/tcp/TCPConnectionEventProc.cc	(working copy)
@@ -128,20 +128,20 @@
             sendSyn();
             startSynRexmitTimer();
             scheduleTimeout(connEstabTimer, TCP_TIMEOUT_CONN_ESTAB);
-            sendQueue->enqueueAppData(msg);  // queue up for later
+            sendQueue->enqueueAppData(PK(msg));  // queue up for later
             tcpEV << sendQueue->getBytesAvailable(state->snd_una) << " bytes in queue\n";
             break;
 
         case TCP_S_SYN_RCVD:
         case TCP_S_SYN_SENT:
             tcpEV << "Queueing up data for sending later.\n";
-            sendQueue->enqueueAppData(msg); // queue up for later
+            sendQueue->enqueueAppData(PK(msg)); // queue up for later
             tcpEV << sendQueue->getBytesAvailable(state->snd_una) << " bytes in queue\n";
             break;
 
         case TCP_S_ESTABLISHED:
         case TCP_S_CLOSE_WAIT:
-            sendQueue->enqueueAppData(msg);
+            sendQueue->enqueueAppData(PK(msg));
             tcpEV << sendQueue->getBytesAvailable(state->snd_una) << " bytes in queue, plus "
                   << (state->snd_max-state->snd_una) << " bytes unacknowledged\n";
             tcpAlgorithm->sendCommandInvoked();
Index: src/transport/tcp/TCPReceiveQueue.h
===================================================================
--- src/transport/tcp/TCPReceiveQueue.h	(revision 2038)
+++ src/transport/tcp/TCPReceiveQueue.h	(working copy)
@@ -85,7 +85,7 @@
      * It should return NULL if there's no more data to be passed up --
      * this method is called several times until it returns NULL.
      */
-    virtual cMessage *extractBytesUpTo(uint32 seq) = 0;
+    virtual cPacket *extractBytesUpTo(uint32 seq) = 0;
 
 };
 
Index: src/transport/tcp/TCPConnectionRcvSegment.cc
===================================================================
--- src/transport/tcp/TCPConnectionRcvSegment.cc	(revision 2038)
+++ src/transport/tcp/TCPConnectionRcvSegment.cc	(working copy)
@@ -439,7 +439,7 @@
                 // accordingly! (right now we *always* advertise win=16384,
                 // that is, there's practically no receiver-imposed flow control!)
                 //
-                cMessage *msg;
+                cPacket *msg;
                 while ((msg=receiveQueue->extractBytesUpTo(state->rcv_nxt))!=NULL)
                 {
                     msg->setKind(TCP_I_DATA);  // TBD currently we never send TCP_I_URGENT_DATA
Index: src/transport/tcp/TCPSendQueue.h
===================================================================
--- src/transport/tcp/TCPSendQueue.h	(revision 2038)
+++ src/transport/tcp/TCPSendQueue.h	(working copy)
@@ -115,7 +115,7 @@
      * The msg object should not be referenced after this point (sendQueue may
      * delete it.)
      */
-    virtual void enqueueAppData(cMessage *msg) = 0;
+    virtual void enqueueAppData(cPacket *msg) = 0;
 
     /**
      * Returns the sequence number of the last byte stored in the buffer plus one.
Index: src/transport/tcp/TCPSegment.cc
===================================================================
--- src/transport/tcp/TCPSegment.cc	(revision 2038)
+++ src/transport/tcp/TCPSegment.cc	(working copy)
@@ -35,13 +35,13 @@
 void TCPSegment::parsimPack(cCommBuffer *b)
 {
     TCPSegment_Base::parsimPack(b);
-    doPacking(payloadList);
+    doPacking(b, payloadList);
 }
 
 void TCPSegment::parsimUnpack(cCommBuffer *b)
 {
     TCPSegment_Base::parsimUnpack(b);
-    doUnpacking(payloadList);
+    doUnpacking(b, payloadList);
 }
 
 void TCPSegment::setPayloadArraySize(unsigned int size)
Index: src/transport/tcp/TCPSegment.msg
===================================================================
--- src/transport/tcp/TCPSegment.msg	(revision 2038)
+++ src/transport/tcp/TCPSegment.msg	(working copy)
@@ -58,7 +58,7 @@
 // cMessage::getKind() may be set to an arbitrary value: TCP entities will
 // ignore it and use only the header fields (synBit, ackBit, rstBit).
 //
-message TCPSegment
+packet TCPSegment
 {
     @customize(true);
     // Source Port
Index: src/transport/tcp/queues/TCPMsgBasedSendQueue.cc
===================================================================
--- src/transport/tcp/queues/TCPMsgBasedSendQueue.cc	(revision 2038)
+++ src/transport/tcp/queues/TCPMsgBasedSendQueue.cc	(working copy)
@@ -45,7 +45,7 @@
     return out.str();
 }
 
-void TCPMsgBasedSendQueue::enqueueAppData(cMessage *msg)
+void TCPMsgBasedSendQueue::enqueueAppData(cPacket *msg)
 {
     //tcpEV << "sendQ: " << info() << " enqueueAppData(bytes=" << msg->getByteLength() << ")\n";
     end += msg->getByteLength();
@@ -79,7 +79,7 @@
     while (i!=payloadQueue.end() && seqLE(i->endSequenceNo, toSeq))
     {
         if (!payloadName) payloadName = i->msg->getName();
-        tcpseg->addPayloadMessage((cMessage *)i->msg->dup(), i->endSequenceNo);
+        tcpseg->addPayloadMessage(i->msg->dup(), i->endSequenceNo);
         ++i;
     }
 
Index: src/transport/tcp/queues/TCPMsgBasedRcvQueue.cc
===================================================================
--- src/transport/tcp/queues/TCPMsgBasedRcvQueue.cc	(revision 2038)
+++ src/transport/tcp/queues/TCPMsgBasedRcvQueue.cc	(working copy)
@@ -57,7 +57,7 @@
 {
     TCPVirtualDataRcvQueue::insertBytesFromSegment(tcpseg);
 
-    cMessage *msg;
+    cPacket *msg;
     uint32 endSeqNo;
     while ((msg=tcpseg->removeFirstPayloadMessage(endSeqNo))!=NULL)
     {
@@ -70,7 +70,7 @@
     return rcv_nxt;
 }
 
-cMessage *TCPMsgBasedRcvQueue::extractBytesUpTo(uint32 seq)
+cPacket *TCPMsgBasedRcvQueue::extractBytesUpTo(uint32 seq)
 {
     extractTo(seq);
 
@@ -78,7 +78,7 @@
     if (payloadList.empty() || seqGreater(payloadList.begin()->first, seq))
         return NULL;
 
-    cMessage *msg = payloadList.begin()->second;
+    cPacket *msg = payloadList.begin()->second;
     payloadList.erase(payloadList.begin());
     return msg;
 }
Index: src/transport/tcp/queues/TCPMsgBasedSendQueue.h
===================================================================
--- src/transport/tcp/queues/TCPMsgBasedSendQueue.h	(revision 2038)
+++ src/transport/tcp/queues/TCPMsgBasedSendQueue.h	(working copy)
@@ -33,7 +33,7 @@
     struct Payload
     {
         unsigned int endSequenceNo;
-        cMessage *msg;
+        cPacket *msg;
     };
     typedef std::list<Payload> PayloadQueue;
     PayloadQueue payloadQueue;
@@ -65,7 +65,7 @@
     /**
      *
      */
-    virtual void enqueueAppData(cMessage *msg);
+    virtual void enqueueAppData(cPacket *msg);
 
     /**
      *
Index: src/transport/tcp/queues/TCPMsgBasedRcvQueue.h
===================================================================
--- src/transport/tcp/queues/TCPMsgBasedRcvQueue.h	(revision 2038)
+++ src/transport/tcp/queues/TCPMsgBasedRcvQueue.h	(working copy)
@@ -33,7 +33,7 @@
 class INET_API TCPMsgBasedRcvQueue : public TCPVirtualDataRcvQueue
 {
   protected:
-    typedef std::map<uint32, cMessage *> PayloadList;
+    typedef std::map<uint32, cPacket *> PayloadList;
     PayloadList payloadList;
 
   public:
@@ -65,7 +65,7 @@
     /**
      *
      */
-    virtual cMessage *extractBytesUpTo(uint32 seq);
+    virtual cPacket *extractBytesUpTo(uint32 seq);
 
 };
 
Index: src/transport/tcp/queues/TCPVirtualDataSendQueue.cc
===================================================================
--- src/transport/tcp/queues/TCPVirtualDataSendQueue.cc	(revision 2038)
+++ src/transport/tcp/queues/TCPVirtualDataSendQueue.cc	(working copy)
@@ -43,7 +43,7 @@
     return out.str();
 }
 
-void TCPVirtualDataSendQueue::enqueueAppData(cMessage *msg)
+void TCPVirtualDataSendQueue::enqueueAppData(cPacket *msg)
 {
     //tcpEV << "sendQ: " << info() << " enqueueAppData(bytes=" << msg->getByteLength() << ")\n";
     end += msg->getByteLength();
Index: src/transport/tcp/queues/TCPVirtualDataRcvQueue.cc
===================================================================
--- src/transport/tcp/queues/TCPVirtualDataRcvQueue.cc	(revision 2038)
+++ src/transport/tcp/queues/TCPVirtualDataRcvQueue.cc	(working copy)
@@ -126,13 +126,13 @@
     }
 }
 
-cMessage *TCPVirtualDataRcvQueue::extractBytesUpTo(uint32 seq)
+cPacket *TCPVirtualDataRcvQueue::extractBytesUpTo(uint32 seq)
 {
     ulong numBytes = extractTo(seq);
     if (numBytes==0)
         return NULL;
 
-    cMessage *msg = new cMessage("data");
+    cPacket *msg = new cPacket("data");
     msg->setByteLength(numBytes);
     return msg;
 }
Index: src/transport/tcp/queues/TCPVirtualDataSendQueue.h
===================================================================
--- src/transport/tcp/queues/TCPVirtualDataSendQueue.h	(revision 2038)
+++ src/transport/tcp/queues/TCPVirtualDataSendQueue.h	(working copy)
@@ -58,7 +58,7 @@
     /**
      *
      */
-    virtual void enqueueAppData(cMessage *msg);
+    virtual void enqueueAppData(cPacket *msg);
 
     /**
      *
Index: src/transport/tcp/queues/TCPVirtualDataRcvQueue.h
===================================================================
--- src/transport/tcp/queues/TCPVirtualDataRcvQueue.h	(revision 2038)
+++ src/transport/tcp/queues/TCPVirtualDataRcvQueue.h	(working copy)
@@ -77,7 +77,7 @@
     /**
      *
      */
-    virtual cMessage *extractBytesUpTo(uint32 seq);
+    virtual cPacket *extractBytesUpTo(uint32 seq);
 
 };
 
Index: src/transport/udp/UDPPacket.msg
===================================================================
--- src/transport/udp/UDPPacket.msg	(revision 2038)
+++ src/transport/udp/UDPPacket.msg	(working copy)
@@ -26,7 +26,7 @@
 //
 // Represents an \UDP packet, to be used with the UDP module.
 //
-message UDPPacket
+packet UDPPacket
 {
     int sourcePort = -1;
     int destinationPort = -1;
Index: src/transport/udp/UDP.cc
===================================================================
--- src/transport/udp/UDP.cc	(revision 2038)
+++ src/transport/udp/UDP.cc	(working copy)
@@ -200,14 +200,14 @@
     if (msg->arrivedOn("ipIn") || msg->arrivedOn("ipv6In"))
     {
         if (dynamic_cast<ICMPMessage *>(msg) || dynamic_cast<ICMPv6Message *>(msg))
-            processICMPError(msg);
+            processICMPError(PK(msg));
         else
             processUDPPacket(check_and_cast<UDPPacket *>(msg));
     }
     else // received from application layer
     {
         if (msg->getKind()==UDP_C_DATA)
-            processMsgFromApp(msg);
+            processMsgFromApp(PK(msg));
         else
             processCommandFromApp(msg);
     }
@@ -263,7 +263,7 @@
            (sd->remoteAddr.isUnspecified() || sd->remoteAddr==remoteAddr);
 }
 
-void UDP::sendUp(cMessage *payload, UDPPacket *udpHeader, IPControlInfo *ipCtrl, SockDesc *sd)
+void UDP::sendUp(cPacket *payload, UDPPacket *udpHeader, IPControlInfo *ipCtrl, SockDesc *sd)
 {
     // send payload with UDPControlInfo up to the application -- IPv4 version
     UDPControlInfo *udpCtrl = new UDPControlInfo();
@@ -280,7 +280,7 @@
     numPassedUp++;
 }
 
-void UDP::sendUp(cMessage *payload, UDPPacket *udpHeader, IPv6ControlInfo *ipCtrl, SockDesc *sd)
+void UDP::sendUp(cPacket *payload, UDPPacket *udpHeader, IPv6ControlInfo *ipCtrl, SockDesc *sd)
 {
     // send payload with UDPControlInfo up to the application -- IPv6 version
     UDPControlInfo *udpCtrl = new UDPControlInfo();
@@ -324,7 +324,7 @@
     }
 }
 
-void UDP::processICMPError(cMessage *msg)
+void UDP::processICMPError(cPacket *msg)
 {
     // extract details from the error message, then try to notify socket that sent bogus packet
     int type, code;
@@ -437,7 +437,7 @@
     int matches = 0;
 
     // deliver a copy of the packet to each matching socket
-    cMessage *payload = udpPacket->getEncapsulatedMsg();
+    cPacket *payload = udpPacket->getEncapsulatedMsg();
     if (dynamic_cast<IPControlInfo *>(ctrl)!=NULL)
     {
         IPControlInfo *ctrl4 = (IPControlInfo *)ctrl;
@@ -447,7 +447,7 @@
             if (sd->onlyLocalPortIsSet || matchesSocket(sd, udpPacket, ctrl4))
             {
                 EV << "Socket sockId=" << sd->sockId << " matches, sending up a copy.\n";
-                sendUp((cMessage*)payload->dup(), udpPacket, ctrl4, sd);
+                sendUp((cPacket*)payload->dup(), udpPacket, ctrl4, sd);
                 matches++;
             }
         }
@@ -461,7 +461,7 @@
             if (sd->onlyLocalPortIsSet || matchesSocket(sd, udpPacket, ctrl6))
             {
                 EV << "Socket sockId=" << sd->sockId << " matches, sending up a copy.\n";
-                sendUp((cMessage*)payload->dup(), udpPacket, ctrl6, sd);
+                sendUp((cPacket*)payload->dup(), udpPacket, ctrl6, sd);
                 matches++;
             }
         }
@@ -484,7 +484,7 @@
 }
 
 
-void UDP::processMsgFromApp(cMessage *appData)
+void UDP::processMsgFromApp(cPacket *appData)
 {
     UDPControlInfo *udpCtrl = check_and_cast<UDPControlInfo *>(appData->removeControlInfo());
 
Index: src/transport/udp/UDP.h
===================================================================
--- src/transport/udp/UDP.h	(revision 2038)
+++ src/transport/udp/UDP.h	(working copy)
@@ -99,19 +99,19 @@
     virtual bool matchesSocket(SockDesc *sd, UDPPacket *udp, IPControlInfo *ctrl);
     virtual bool matchesSocket(SockDesc *sd, UDPPacket *udp, IPv6ControlInfo *ctrl);
     virtual bool matchesSocket(SockDesc *sd, const IPvXAddress& localAddr, const IPvXAddress& remoteAddr, short remotePort);
-    virtual void sendUp(cMessage *payload, UDPPacket *udpHeader, IPControlInfo *ctrl, SockDesc *sd);
-    virtual void sendUp(cMessage *payload, UDPPacket *udpHeader, IPv6ControlInfo *ctrl, SockDesc *sd);
+    virtual void sendUp(cPacket *payload, UDPPacket *udpHeader, IPControlInfo *ctrl, SockDesc *sd);
+    virtual void sendUp(cPacket *payload, UDPPacket *udpHeader, IPv6ControlInfo *ctrl, SockDesc *sd);
     virtual void processUndeliverablePacket(UDPPacket *udpPacket, cPolymorphic *ctrl);
     virtual void sendUpErrorNotification(SockDesc *sd, int msgkind, const IPvXAddress& localAddr, const IPvXAddress& remoteAddr, short remotePort);
 
     // process an ICMP error packet
-    virtual void processICMPError(cMessage *icmpErrorMsg); // TODO use ICMPMessage
+    virtual void processICMPError(cPacket *icmpErrorMsg); // TODO use ICMPMessage
 
     // process UDP packets coming from IP
     virtual void processUDPPacket(UDPPacket *udpPacket);
 
     // process packets from application
-    virtual void processMsgFromApp(cMessage *appData);
+    virtual void processMsgFromApp(cPacket *appData);
 
     // process commands from application
     virtual void processCommandFromApp(cMessage *msg);
Index: src/transport/contract/TCPSocket.cc
===================================================================
--- src/transport/contract/TCPSocket.cc	(revision 2038)
+++ src/transport/contract/TCPSocket.cc	(working copy)
@@ -241,13 +241,13 @@
     {
         case TCP_I_DATA:
              if (cb)
-                 cb->socketDataArrived(connId, yourPtr, msg, false);
+                 cb->socketDataArrived(connId, yourPtr, PK(msg), false);
              else
                  delete msg;
              break;
         case TCP_I_URGENT_DATA:
              if (cb)
-                 cb->socketDataArrived(connId, yourPtr, msg, true);
+                 cb->socketDataArrived(connId, yourPtr, PK(msg), true);
              else
                  delete msg;
              break;
Index: src/transport/contract/TCPSocket.h
===================================================================
--- src/transport/contract/TCPSocket.h	(revision 2038)
+++ src/transport/contract/TCPSocket.h	(working copy)
@@ -68,7 +68,7 @@
  * class MyModule : public cSimpleModule, public TCPSocket::CallbackInterface
  * {
  *     TCPSocket socket;
- *     virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent);
+ *     virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent);
  *     virtual void socketFailure(int connId, void *yourPtr, int code);
  *     ...
  * };
@@ -84,7 +84,7 @@
  *         ...
  * }
  *
- * void MyModule::socketDataArrived(int, void *, cMessage *msg, bool) {
+ * void MyModule::socketDataArrived(int, void *, cPacket *msg, bool) {
  *     ev << "Received TCP data, " << msg->getByteLength() << " bytes\\n";
  *     delete msg;
  * }
@@ -136,7 +136,7 @@
     {
       public:
         virtual ~CallbackInterface() {}
-        virtual void socketDataArrived(int connId, void *yourPtr, cMessage *msg, bool urgent) = 0;
+        virtual void socketDataArrived(int connId, void *yourPtr, cPacket *msg, bool urgent) = 0;
         virtual void socketEstablished(int connId, void *yourPtr) {}
         virtual void socketPeerClosed(int connId, void *yourPtr) {}
         virtual void socketClosed(int connId, void *yourPtr) {}
Index: src/transport/contract/UDPSocket.h
===================================================================
--- src/transport/contract/UDPSocket.h	(revision 2038)
+++ src/transport/contract/UDPSocket.h	(working copy)
@@ -65,7 +65,7 @@
  * class MyModule : public cSimpleModule, public UDPSocket::CallbackInterface
  * {
  *    UDPSocket socket;
- *    virtual void socketDataArrived(int sockId, void *yourPtr, cMessage *msg, bool urgent);
+ *    virtual void socketDataArrived(int sockId, void *yourPtr, cPacket *msg, bool urgent);
  *    virtual void socketFailure(int sockId, void *yourPtr, int code);
  *    ...
  * };
Index: src/base/INETDefs.h
===================================================================
--- src/base/INETDefs.h	(revision 2038)
+++ src/base/INETDefs.h	(working copy)
@@ -68,6 +68,9 @@
 #define CHK(x) __checknull((x), #x, __FILE__, __LINE__)
 
 
+#define PK(msg)  check_and_cast<cPacket *>(msg)    /*XXX temp def*/
+
+
 #ifdef _MSC_VER
 //
 // Implementation of the error function, from the Mobility Framework
Index: src/base/ByteArrayMessage.msg
===================================================================
--- src/base/ByteArrayMessage.msg	(revision 2038)
+++ src/base/ByteArrayMessage.msg	(working copy)
@@ -20,7 +20,7 @@
 //
 // Message that carries raw bytes. Used with emulation-related features.
 //
-message ByteArrayMessage
+packet ByteArrayMessage
 {
     @customize(true);
     char data[];
Index: src/base/Sink.cc
===================================================================
--- src/base/Sink.cc	(revision 2038)
+++ src/base/Sink.cc	(working copy)
@@ -38,7 +38,7 @@
 void Sink::handleMessage(cMessage *msg)
 {
     numPackets++;
-    numBits += msg->getBitLength();
+    numBits += PK(msg)->getBitLength();
 
     throughput = numBits / simTime();
     packetPerSec = numPackets / simTime();
Index: src/util/ThruputMeteringChannel.cc
===================================================================
--- src/util/ThruputMeteringChannel.cc	(revision 2038)
+++ src/util/ThruputMeteringChannel.cc	(working copy)
@@ -1,5 +1,5 @@
 //FIXME to be updated and enabled again
-#if 0
+#if 0//XXX
 
 //
 // Copyright (C) 2005 Andras Varga
@@ -176,7 +176,7 @@
     *p = '\0';
 
     // display label
-    getFromGate()->getDisplayString().setTagArg("t", 0, buf);
+    getSourceGate()->getDisplayString().setTagArg("t", 0, buf);
 }
 
 #endif
Index: src/util/ThruputMeteringChannel.h
===================================================================
--- src/util/ThruputMeteringChannel.h	(revision 2038)
+++ src/util/ThruputMeteringChannel.h	(working copy)
@@ -1,5 +1,5 @@
 //FIXME upgrade and put back!!
-#if 0
+#if 0//XXX
 
 //
 // Copyright (C) 2005 Andras Varga
Index: src/util/TCPDump.cc
===================================================================
--- src/util/TCPDump.cc	(revision 2038)
+++ src/util/TCPDump.cc	(working copy)
@@ -163,7 +163,7 @@
         else
         {
             // search for encapsulated IP[v6]Datagram in it
-            cMessage *encapmsg = msg;
+            cPacket *encapmsg = PK(msg);
             while (encapmsg && dynamic_cast<IPDatagram *>(encapmsg)==NULL && dynamic_cast<IPv6Datagram_Base *>(encapmsg)==NULL)
                 encapmsg = encapmsg->getEncapsulatedMsg();
             if (!encapmsg)
Index: src/util/headerserializers/IPSerializer.cc
===================================================================
--- src/util/headerserializers/IPSerializer.cc	(revision 2038)
+++ src/util/headerserializers/IPSerializer.cc	(working copy)
@@ -116,7 +116,7 @@
         EV << "Can not handle IP packet of total length " << totalLength << "(captured only " << bufsize << " bytes).\n";
     dest->setByteLength(IP_HEADER_BYTES);
 
-    cMessage *encapPacket = NULL;
+    cPacket *encapPacket = NULL;
     switch (dest->getTransportProtocol())
     {
       case IP_PROT_ICMP:
Index: src/util/headerserializers/UDPSerializer.cc
===================================================================
--- src/util/headerserializers/UDPSerializer.cc	(revision 2038)
+++ src/util/headerserializers/UDPSerializer.cc	(working copy)
@@ -56,7 +56,7 @@
     dest->setSourcePort(ntohs(udphdr->uh_sport));
     dest->setDestinationPort(ntohs(udphdr->uh_dport));
     dest->setByteLength(8);
-    cMessage *encapPacket = new cMessage("Payload-from-wire");
+    cPacket *encapPacket = new cPacket("Payload-from-wire");
     encapPacket->setByteLength(ntohs(udphdr->uh_ulen) - sizeof(struct udphdr));
     dest->encapsulate(encapPacket);
     dest->setName(encapPacket->getName());
Index: src/util/NAMTraceWriter.cc
===================================================================
--- src/util/NAMTraceWriter.cc	(revision 2038)
+++ src/util/NAMTraceWriter.cc	(working copy)
@@ -78,8 +78,8 @@
 
             // fill in peerNamIds in InterfaceEntries
             cGate *outgate = node->gate(ie->getNodeOutputGateId());
-            if (!outgate || !outgate->getToGate()) continue;
-            cModule *peernode = outgate->getToGate()->getOwnerModule(); // FIXME not entirely correct: what if a subnet is "boxed"?
+            if (!outgate || !outgate->getNextGate()) continue;
+            cModule *peernode = outgate->getNextGate()->getOwnerModule(); // FIXME not entirely correct: what if a subnet is "boxed"?
             cModule *peerwriter = peernode->getSubmodule("namTrace");
             if (!peerwriter) error("module %s doesn't have a submodule named namTrace", peernode->getFullPath().c_str());
             int peernamid = peerwriter->par("namid");
@@ -120,7 +120,7 @@
     {
         TxNotifDetails *d = check_and_cast<TxNotifDetails *>(details);
         int peernamid = d->getInterfaceEntry()->getPeerNamId();
-        cMessage *msg = d->getMessage();
+        cPacket *msg = d->getPacket();
 
         switch(category)
         {
@@ -166,14 +166,14 @@
     out << "q -t * -s " << namid << " -d " << peernamid << " -a 0 " << endl;
 }
 
-void NAMTraceWriter::recordPacketEvent(char event, int peernamid, cMessage *msg)
+void NAMTraceWriter::recordPacketEvent(char event, int peernamid, cPacket *msg)
 {
     ASSERT(nt && nt->isEnabled());
     std::ostream& out = nt->out();
 
     int size = msg->getByteLength();
     int color = 0;
-    for (cMessage *em = msg; em; em = em->getEncapsulatedMsg())
+    for (cPacket *em = msg; em; em = em->getEncapsulatedMsg())
         if (em->hasPar("color"))
             {color = em->par("color").longValue(); break;}
 
Index: src/util/NAMTraceWriter.h
===================================================================
--- src/util/NAMTraceWriter.h	(revision 2038)
+++ src/util/NAMTraceWriter.h	(working copy)
@@ -42,7 +42,7 @@
   protected:
     virtual void recordNodeEvent(const char *state, const char *shape);
     virtual void recordLinkEvent(int peernamid, double datarate, simtime_t delay, const char *state);
-    virtual void recordPacketEvent(char event, int peernamid, cMessage *msg);
+    virtual void recordPacketEvent(char event, int peernamid, cPacket *msg);
 
   protected:
     virtual int numInitStages() const {return 3;}
Index: .oppbuildspec
===================================================================
--- .oppbuildspec	(revision 2038)
+++ .oppbuildspec	(working copy)
@@ -1,3 +1,2 @@
 version 4.0
-src: --deep -o inet -O out
-.: --deep -O out --meta:auto-include-path --meta:use-exported-libs
+src: --deep --make-so -O out --meta:auto-include-path --meta:export-library --meta:use-exported-libs
