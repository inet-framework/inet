\chapter{IPv4}
\label{cha:ipv4}

\section{The IPv4 Module}

\subsection{Processing time}

The C++ class of the \nedtype{IPv4} module is derived from \cppclass{QueueBase}.
There is a processing time associated with each incoming packet.
This processing time is specified by the \fpar{procDelay} module parameter.
If a packet arrives, when the processing of a previous has not been
finished, it is placed in a FIFO queue.

The current performance model assumes that each datagram is processed
within the same time, and there is no priority between the datagrams.
If you need a more sophisticated performance model, you may change
the module implementation (the IP class), and:
\begin{enumerate}
  \item override the \ffunc{startService()} method which determines processing
        time for a packet, or
  \item use a different base class.
\end{enumerate}

\subsection{Interface with higher layer}

Higher layer protocols should be connected to the \ttt{transportIn}/\ttt{transportOut}
gates of the \nedtype{IPv4} module.

\subsubsection*{Sending packets}

Higher layer protocols can send a packet by attaching a \cppclass{IPv4ControlInfo}
object to their packet and sending it to the \nedtype{IPv4} module.

% receiving IP datagrams from higher layer?

The following fields must be set in the control info:
\begin{itemize}
  \item \fvar{procotol}: the \ttt{Protocol} field of the IP datagram. Valid values
        are defined in the \ttt{IPProtocolId} enumeration.
  \item \fvar{destAddr}: the \ttt{Destination Address} of the IP datagram.
\end{itemize}

Optionally the following fields can be set too:
\begin{itemize}
\item \fvar{scrAddr}: \ttt{Source Address} of the IP datagram. If given it must match with the
      address of one of the interfaces of the node, but the datagram is not necessarily
      routed through that interface. If left unspecified, then the address of the
      outgoing interface will be used.
\item \fvar{timeToLive}: TTL of the IP datagram or -1 (unspecified). If unspecified then the TTL
      of the datagram will be 1 for destination addresses in the
      224.0.0.0 -- 224.0.0.255 range. (Datagrams with these special multicast addresses
      do not need to go further that one hop, routers does not forward these datagrams.)
      Otherwise the TTL field is determined by the \fpar{defaultTimeToLive} or
      \fpar{defaultMCTimeToLive} module parameters depending whether the destination
      address is a multicast address or not.
\item \fvar{dontFragment}: the \ttt{Don't Fragment} flag of the outgoing datagram (default is \fkeyword{false})
\item \fvar{diffServCodePoint}: the \ttt{Type of Service} field of the outgoing datagram.
      (ToS is called \ttt{diffServCodePoint} in \msgtype{IPv4Datagram} too.)
\item \fvar{multicastLoop}: if \fkeyword{true}, then a copy of the multicast datagrams
      are sent to the loopback interface, so applications on the same host can receive it.
\item \fvar{interfaceId}: id of outgoing interface (can be used to limit broadcast or restrict routing).
\item \fvar{nextHopAddr}: explicit routing info, used by Manet DSR routing. If specified, then
      \ttt{interfaceId} must also be specified. Ignored in Manet routing is disabled.
\end{itemize}

The IP module encapsulates the transport layer datagram into an \msgtype{IPv4Datagram}
and fills in the header fields according to the control info. The \ttt{Identification}
field is generated by incrementing a counter.

The generated IP datagram is passed to the routing algorithm. The routing decides if the
datagram should be delivered locally, or passed to one of the network interfaces
with a specified next hop address, or broadcasted on one or all of the network interfaces.
The details of the routing is described in the next subsection (\ref{subsec:ip_routing})
in detail.

Before sending the datagram on a specific interface, the \nedtype{IPv4} module
checks if the packet length is smaller than the \ttt{MTU} of the interface.
If not, then the datagram is fragmented. When the \ttt{Don't Fragment} flag
forbids fragmentation, an \ttt{Destination Unreachable} ICMP error is generated
with the \ttt{Fragmentation Error (5)} error code.
\begin{note}
Each fragment will encapsulate the whole higher layer datagram, although the
length of the IP datagram corresponds to the fragment length.
\end{note}

The fragments are sent to the \nedtype{ARP} module through the \ttt{queueOut} gate.
The \nedtype{ARP} module forwards the datagram immediately to point-to-point interface
cards. If the outgoing interface is a 802.x card, then before forwarding the datagram
it performs address resolution to obtain the MAC address of the destination.

\subsubsection*{Receiving packets}

The \nedtype{IPv4} module of hosts processes the datagrams received from the network
in three steps:
\begin{enumerate}
  \item Reassemble fragments
  \item Decapsulate the transport layer datagram
  \item Dispatch the datagram to the appropriate transport protocol
\end{enumerate}

When a fragment received, it is added to the fragment buffer of the IP.
If the fragment was the last fragment of a datagram, the processing of
the datagram continues with step 2. The fragment buffer stores the reception
time of each fragment. Fragments older than \fpar{fragmentTimeout} are
purged from the buffer. The default value of the timeout is 60s. The
timeout is only checked when a fragment is received, and at least 10s
elapsed since the last check.

An \msgtype{IPv4ControlInfo} attached to the decapsulated transport layer packet.
The control info contains fields copied from the IP header (source and destination
address, protocol, TTL, ToS) as well as the interface id through it was received.
The control info also stores the original IP datagram, because the transport
layer might signal an ICMP error, and the ICMP packet must encapsulate the
erronous IP datagram.
\begin{note}
IP datagrams containing a DSR packet are not decapsulated, the unchanged IP
datagram is passed to the DSR module instead.
\end{note}

After decapsulation, the transport layer packet will be passed to the appropriate
transport protocol. It must be connected to one of the \ttt{transportOut[]} gate.
The \nedtype{IPv4} module finds the gate using the \ttt{protocol id}$\rightarrow$
\ttt{gate index} mapping given in the \fpar{protocolMapping} string parameter.
The value must be a comma separated list of ''<protocol\_id>:<gate\_index>'' items.
For example the following line in the ini file maps TCP (6) to gate 0, UDP (17)
to gate 1, ICMP (1) to gate 2, IGMP (2) to gate 3, and RVSP (46) to gate 4.
\begin{inifile}
**.ip.protocolMapping="6:0,17:1,1:2,2:3,46:4"
\end{inifile}
If the protocol of the received IP datagram is not mapped, or the gate
is not connected, the datagram will be silently dropped.
% FIXME (#463) should send DESTINATION_UNREACHABLE/PROTOCOL_UNREACHABLE
% FIXME reassembleAndDeliver() checks that transport gate is connected, but handleReceivedICMP() does not check it

Some protocols are handled differently:
\begin{itemize}
  \item \ttt{ICMP}: ICMP errors are delivered to the protocol
        whose packet triggered the error. Only ICMP query
        requests and responses are sent to the \nedtype{ICMP} module.
  \item \ttt{IP}: sent through \ttt{preRoutingOut} gate. (bug!)
  \item \ttt{DSR}: ??? (subsection about Manet routing?)
\end{itemize}

% FIXME (#462) reassembleAndDeliver(): packets with IP protocol are sent through 'preRoutingOut' gate,
%       but there is no such gate in the IPv4 module.


\subsection{Routing, and interfacing with lower layers}
\label{subsec:ip_routing}

The output of the network interfaces are connected to the
\ttt{queueIn} gates of the \nedtype{IPv4} module. The incoming
packets are either IP datagrams or ARP responses. The IP datagrams
are processed by the \nedtype{IPv4} module, the ARP
responses are forwarded to the \nedtype{ARP}.

The \nedtype{IPv4} module first checks the error bit of the
incoming IP datagrams. There is a $header length/packet length$
probability that the IP header contains the error (assuming
1~bit error). With this probability an ICMP \ttt{Parameter Problem}
generated, and the datagram is dropped.

% FIXME (#466) if IP datagram hasBitError(), but it is decided not be in the IP header,
%       then the decapsulated packet should have the bit error.

When the datagram does not contain error in the IP header,
a routing decision is made. As a result of the routing
the datagram is either delivered locally,
or sent out one or more output interface.
When it is sent out, the routing algorithm must compute the
next hop of its route. The details are differ, depending on
that the destination address is multicast address or not.

When the datagram is decided to be sent up, it is processed
as described in the previous subsection (Receiving packets).
If it is decided to be sent out through some interface, it
is actually sent to the \nedtype{ARP} module through the
\ttt{queueOut} gate. An \msgtype{IPv4RoutingDecision} control
info is attached to the outgoing packet, containing the
outgoing interface id, and the IP address of the next hop.
The \nedtype{ARP} module resolve the IP address to a hardware
address if needed, and forwards the datagram to next hop.

\subsubsection*{Unicast/broadcast routing}

When the higher layer generated the datagram, it will be processed
in these steps:
\begin{enumerate}
  \item If the destination is the address of a local interface,
  then the datagram is locally delivered.
  \item If the destination is the limited broadcast address, or a
  local broadcast address, then it will be broadcasted on one or more
  interface. If the higher layer specified am outgoing interface
  (\fvar{interfaceId} in the control info), then it will be broadcasted
  on that interface only. Otherwise if the \fpar{forceBroadcast} module
  parameter is \fkeyword{true}, then it will broadcasted on all interfaces
  including the loopback interface. The default value of the
  \fpar{forceBroadcast} is \fkeyword{false}.
  \item If the higher layer provided the routing decision (Manet routing),
  then the datagram will be sent through the specified interface to the
  specified next hop.
  \item Otherwise IP finds the outgoing interface and the address of the
  next hop by consulting the routing table, and sends the datagram
  to the next hop. If no route
  found, then a \ttt{Destination Unreachable} ICMP error is generated.
\end{enumerate}


Incoming datagrams having unicast or broadcast destination addresses are
routed in the following steps:

\begin{enumerate}
  \item Deliver datagram locally. If the destination address is a local
  address, the limited broadcast address (255.255.255.255), or a local
  broadcast address, then it will be sent to the transport layer.
  \item Drop packets received from the network when IP forwarding is disabled.
  \item Forward the datagram to the next hop. The next hop is
    determined by looking up the best route to the destination from the
    routing table. If the gateway is set in the route, then the datagram
    will be forwarded to the gateway, otherwise it is sent directly to the
    destination. If no route is found, then
    a \ttt{Destination Unreachable} ICMP error is sent to the source of the
    datagram.
\end{enumerate}

\subsubsection*{Multicast routing}

Outgoing multicast datagrams are handled as follows:
\begin{enumerate}
  \item If the higher layer set the \fvar{multicastLoop} variable
  to \fkeyword{true}, the IP will send up a copy of the datagram
  through the loopback interface.
  \item Determine the outgoing interface for the multicast datagram,
  and send out the datagram through that interface. The outgoing
  interface is determined by the following rules:
  \begin{compactenum}
    \item if the HL specified the outgoing interface in the control
    info, the it will be used
    \item otherwise use the interface of the route configured in the
    routing table for the destination address
    \item if no route found, then use the interface whose address
    matches the source address of the datagram
    \item if the HL did not specify the source address, then use
    the first multicast capable interface
    \item if no such interface found, then the datagram is unroutable
    and droppped
  \end{compactenum}
\end{enumerate}


Incoming multicast datagrams are forwarded according to their source address
(Reverse Path Forwarding), i.e. datagrams are sent away from their sources instead
towards their destinations. The multicast routing table maintains a spanning tree
for each source network and multicast group. The source network is the root of the
tree, and there is a path to each LAN that has members of the multicast group.
Each node expects the multicast datagram to arrive from their parent and forwards
them towards their children. Multicast forwarding loops are avoided by dropping the
datagrams not arrived on the parent interface.

More specifically, the routing routine for multicast datagrams performs these steps:
\begin{enumerate}
  \item Deliver a copy of the datagram locally. If the interface on which
  the datagram arrived belongs to the multicast group specified by the
  destination address, it is sent up to the transport layer.
  \item Discard incoming packets that can not be delivered locally and
  can not be forwarded.
  A non-local packet can not be forwarded if multicast forwarding is disabled,
  the destination is a link local multicast address (224.0.0.x), or
  the TTL field reached 0.
  \item Discard the packet if no multicast route found, or
  if it did not arrive on the parent interface of the route
  (to avoid multicast loops). If the parent is not set in the route,
  then the shortest path interface to the source is assumed.
  \item Forward the multicast datagram.
  A copy of the datagram is sent on each child interface described by
  multicast routes (except the incoming interface). Interfaces may have
  a \fvar{ttlThreshold} parameter, that limits the scope of the multicast:
  only datagrams with higher TTL are forwarded.
\end{enumerate}

\section{The IPv4RoutingTable Module}

Interfaces are dynamically registered: at the start of the simulation,
every L2 module adds its own interface entry to the table.

The route table is read from a file; the file can
also fill in or overwrite interface settings. The route table can also
be read and modified during simulation, typically by routing protocol
implementations (e.g. OSPF).

Entries in the route table are represented by \cppclass{IPv4Route} objects.
\cppclass{IPv4Route} objects can be polymorphic: if a routing protocol needs
to store additional data, it can simply subclass from \cppclass{IPv4Route},
and add the derived object to the table. The \cppclass{IPv4Route} object
has the following fields:
\begin{itemize}
  \item \ttt{host} is the IP address of the target of the route (can be a host or network).
                   When an entry searched for a given destination address, the destination
                   address is compared with this \ttt{host} address using the \ttt{netmask}
                   below, and the longest match wins.
  \item \ttt{netmask} used when comparing \ttt{host} with the detination address.
                     It is 0.0.0.0 for the default route, 255.255.255.255 for
                     host routes (exact match), or the network or subnet mask
                     for network routes.
  \item \ttt{gateway} is the IP address of the gateway for indirect routes, or
                      0.0.0.0 for direct routes. Note that 0.0.0.0 can be used
                      even if the destination is not directly connected to this
                      node, but can be found using proxy ARP.
  \item \ttt{interface} the outgoing interface to be used with this route.
  \item \ttt{type} \ttt{DIRECT} or \ttt{REMOTE}. For direct routes, the next hop
                   address is the destination address, for remote routes it is
                   the gateway address.
  \item \ttt{source} \ttt{MANUAL}, \ttt{IFACENETMASK}, \ttt{RIP}, \ttt{OSPF},
        \ttt{BGP}, \ttt{ZEBRA}, \ttt{MANET}, or \ttt{MANET2}. \ttt{MANUAL} means
        that the route was added by a routing file, or a network configurator.
        \ttt{IFACENETMASK} routes are added for each interface of the node.
        Other values means that the route is managed by the specific routing
        daemon.
  \item \ttt{metric} the ``cost'' of the route. Currently not used when choosing
                     the best route.
\end{itemize}

% TODO describe Reverse Path Forwarding

In multicast routers the routing table contains multicast routes too.
A multicast route is represented by an instance of the \cppclass{IPv4MulticastRoute}
class. The \cppclass{IPv4MulticastRoute} instance stores the following fields:
\begin{itemize}
  \item \fvar{origin} IP address of the network of the source of the datagram
  \item \fvar{originNetmask} netmask of the source network
  \item \fvar{group} the multicast group to be matched the destination of the
  datagram. If unspecified, then the route matches with
  \item \fvar{parent} interface towards the parent link in the multicast tree.
  Only those datagrams are forwarded that arrived on the parent interface.
  \item \fvar{children} the interfaces on which the multicast datagram to be forwarded.
  Each entry contains a flag indicating if this interface is a leaf in the multicast
  tree. The datagram is forwarded to leaf interfaces only if there are known members
  of the group in the attached LAN.
  \item \fvar{source} enumerated value identifying the creator of the entry. \ttt{MANUAL}
  for static routes, \ttt{DVRMP} for the DVMRP routers, \ttt{PIM\_SM} for PIM SM routers.
  \item \fvar{metric} the ``cost`` of the route.
\end{itemize}

When there are several multicast routes matching the source and destination
of the datagram, then the forwarding algorithm chooses the one with the
\begin{enumerate}
  \item the longest matching source
  \item the more specific group
  \item the smallest metric.
\end{enumerate}


\section{The ICMP Module}

The \nedtype{ICMP} module has two methods which can be used by other modules
to send ICMP error messages:
\begin{itemize}
  \item \ffunc[sendErrorMessage]{sendErrorMessage(IPv4Datagram*, ICMPType, ICMPCode)}
        used by the network layer to report erronous IPv4 datagrams. The ICMP header
        fields are set to the given type and code, and the ICMP message will encapsulate
        the given datagram.
  \item \ffunc[sendErrorMessage]{sendErrorMessage(cPacket*, IPv4ControlInfo*, ICMPType, ICMPCode)}
        used by the transport layer components to report erronous packets. The transport
        packet will be encapsulated into an IP datagram before wrapping it into the ICMP message.
\end{itemize}

The \nedtype{ICMP} module can be accessed from other modules of the node by calling
\ffunc{ICMPAccess::get()}.

When an incoming ICMP error message is received, the \nedtype{ICMP} module
sends it out on the \ttt{errorOut} gate unchanged. It is assumed that an
external module is connected to \ttt{errOut} that can process the error
packet. There is a simple module (\nedtype{ErrorHandling}) that simply
logs the error and drops the message. Note that the \nedtype{IPv4} module
does not send REDIRECT, DESTINATION\_UNREACHABLE,
TIME\_EXCEEDED and PARAMETER\_PROBLEM messages to the \nedtype{ICMP} module,
it will send them to the transport layer module that sent the bogus
packet encapsulated in the ICMP message.
\begin{note}
ICMP protocol encapsulates only the IP header + 8 byte following the IP header
from the bogus IP packet. The ICMP packet length computed from this truncated
packet, despite it encapsulates the whole IP message object.
As a consequence, calling \ffunc{decapsulate()} on the ICMP message
will cause an ``packet length became negative'' error. To avoid this,
use \ffunc{getEncapsulatedMsg()} to access the IP packet that caused the ICMP
error.
\end{note}

The \nedtype{ICMP} module receives ping commands on the \ttt{pingIn}
gate from the application. The ping command can be any packet
having an \cppclass{IPv4ControlInfo} control info. The packet
will be encapsulated with an \msgtype{ICMPMessage} and
handed over to the IP.

If \nedtype{ICMP} receives an echo request from IP, the original
message object will be returned as the echo reply. Of course,
before sending back the object to IP, the source and destination
addresses are swapped and the message type changed to ICMP\_ECHO\_REPLY.

When an ICMP echo reply received, the application message decapsulated
from it and passed to the application through the \ttt{pingOut} gate.
The \cppclass{IPv4ControlInfo} also copied from the \msgtype{ICMPMessage}
to the application message.

% FIXME ICMP TIMESTAMP requests are processed as ECHO requests


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "usman"
%%% End:

