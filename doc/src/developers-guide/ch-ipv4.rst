:orphan:

.. _dg:cha:ipv4:

Ipv4
====

The IPv4 Module
---------------

Processing time
~~~~~~~~~~~~~~~

The C++ class of the :ned:`Ipv4` module is derived from
:cpp:`QueueBase`. There is a processing time associated with each
incoming packet. This processing time is specified by the
:par:`procDelay` module parameter. If a packet arrives, when the
processing of a previous has not been finished, it is placed in a FIFO
queue.

The current performance model assumes that each datagram is processed
within the same time, and there is no priority between the datagrams. If
you need a more sophisticated performance model, you may change the
module implementation (the IP class), and:

#. override the :fun:`startService()` method which determines
   processing time for a packet, or

#. use a different base class.

Interface with higher layer
~~~~~~~~~~~~~~~~~~~~~~~~~~~

Higher layer protocols should be connected to the
``transportIn``/``transportOut`` gates of the :ned:`Ipv4` module.

Sending packets
^^^^^^^^^^^^^^^

Higher layer protocols can send a packet by attaching a
:cpp:`Ipv4ControlInfo` object to their packet and sending it to the
:ned:`Ipv4` module.

The following fields must be set in the control info:

-  :var:`procotol`: the ``Protocol`` field of the IP datagram. Valid
   values are defined in the ``IpProtocolId`` enumeration.

-  :var:`destAddr`: the ``Destination Address`` of the IP datagram.

Optionally the following fields can be set too:

-  :var:`scrAddr`: ``Source Address`` of the IP datagram. If given it
   must match with the address of one of the interfaces of the node, but
   the datagram is not necessarily routed through that interface. If
   left unspecified, then the address of the outgoing interface will be
   used.

-  :var:`timeToLive`: TTL of the IP datagram or -1 (unspecified). If
   unspecified then the TTL of the datagram will be 1 for destination
   addresses in the 224.0.0.0 – 224.0.0.255 range. (Datagrams with these
   special multicast addresses do not need to go further that one hop,
   routers does not forward these datagrams.) Otherwise the TTL field is
   determined by the :par:`defaultTimeToLive` or
   :par:`defaultMCTimeToLive` module parameters depending whether the
   destination address is a multicast address or not.

-  :var:`dontFragment`: the ``Don’t Fragment`` flag of the outgoing
   datagram (default is ``false``)

-  :var:`diffServCodePoint`: the ``Type of Service`` field of the
   outgoing datagram. (ToS is called ``diffServCodePoint`` in
   :msg:`Ipv4Header` too.)

-  :var:`multicastLoop`: if ``true``, then a copy of the multicast
   datagrams are sent to the loopback interface, so applications on the
   same host can receive it.

-  :var:`interfaceId`: id of outgoing interface (can be used to limit
   broadcast or restrict routing).

-  :var:`nextHopAddr`: explicit routing info, used by Manet DSR routing.
   If specified, then ``interfaceId`` must also be specified. Ignored
   in Manet routing is disabled.

The IP module encapsulates the transport layer datagram into an
:msg:`Ipv4Header` and fills in the header fields according to the
control info. The ``Identification`` field is generated by
incrementing a counter.

The generated IP datagram is passed to the routing algorithm. The
routing decides if the datagram should be delivered locally, or passed
to one of the network interfaces with a specified next hop address, or
broadcasted on one or all of the network interfaces. The details of the
routing is described in the next subsection
(`1.1.3 <#subsec:ip_routing>`__) in detail.

Before sending the datagram on a specific interface, the :ned:`Ipv4`
module checks if the packet length is smaller than the ``MTU`` of the
interface. If not, then the datagram is fragmented. When the ``Don’t
Fragment`` flag forbids fragmentation, an ``Destination Unreachable``
ICMP error is generated with the ``Fragmentation Error (5)`` error
code.

.. note::

   Each fragment will encapsulate the whole higher layer datagram, although the
   length of the IP datagram corresponds to the fragment length.

The fragments are sent to the :ned:`Arp` module through the
``queueOut`` gate. The :ned:`Arp` module forwards the datagram
immediately to point-to-point interface cards. If the outgoing interface
is a 802.x card, then before forwarding the datagram it performs address
resolution to obtain the MAC address of the destination.

Receiving packets
^^^^^^^^^^^^^^^^^

The :ned:`Ipv4` module of hosts processes the datagrams received from
the network in three steps:

#. Reassemble fragments

#. Decapsulate the transport layer datagram

#. Dispatch the datagram to the appropriate transport protocol

When a fragment received, it is added to the fragment buffer of the IP.
If the fragment was the last fragment of a datagram, the processing of
the datagram continues with step 2. The fragment buffer stores the
reception time of each fragment. Fragments older than
:par:`fragmentTimeout` are purged from the buffer. The default value of
the timeout is 60s. The timeout is only checked when a fragment is
received, and at least 10s elapsed since the last check.

An :msg:`Ipv4ControlInfo` attached to the decapsulated transport layer
packet. The control info contains fields copied from the IP header
(source and destination address, protocol, TTL, ToS) as well as the
interface id through it was received. The control info also stores the
original IP datagram, because the transport layer might signal an ICMP
error, and the ICMP packet must encapsulate the erronous IP datagram.

.. note::

   IP datagrams containing a DSR packet are not decapsulated, the unchanged IP
   datagram is passed to the DSR module instead.

After decapsulation, the transport layer packet will be passed to the
appropriate transport protocol. It must be connected to one of the
``transportOut[]`` gate. The :ned:`Ipv4` module finds the gate using
the ``protocol id``\ :math:`\rightarrow` ``gate index`` mapping
given in the :par:`protocolMapping` string parameter. The value must be
a comma separated list of ”<protocol_id>:<gate_index>” items. For
example the following line in the ini file maps TCP (6) to gate 0, UDP
(17) to gate 1, ICMP (1) to gate 2, IGMP (2) to gate 3, and RVSP (46) to
gate 4.

.. code-block:: ini

   **.ip.protocolMapping="6:0,17:1,1:2,2:3,46:4"

If the protocol of the received IP datagram is not mapped, or the gate
is not connected, the datagram will be silently dropped.

Some protocols are handled differently:

-  :ned:`Icmp`: ICMP errors are delivered to the protocol whose packet
   triggered the error. Only ICMP query requests and responses are sent
   to the :ned:`Icmp` module.

-  ``IP``: sent through ``preRoutingOut`` gate. (bug!)

-  ``DSR``: ??? (subsection about Manet routing?)

.. _subsec:ip_routing:

Routing, and interfacing with lower layers
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

The output of the network interfaces are connected to the ``queueIn``
gates of the :ned:`Ipv4` module. The incoming packets are either IP
datagrams or ARP responses. The IP datagrams are processed by the
:ned:`Ipv4` module, the ARP responses are forwarded to the :ned:`Arp`.

The :ned:`Ipv4` module first checks the error bit of the incoming IP
datagrams. There is a :math:`header length/packet length` probability
that the IP header contains the error (assuming 1 bit error). With this
probability an ICMP ``Parameter Problem`` generated, and the datagram
is dropped.

When the datagram does not contain error in the IP header, a routing
decision is made. As a result of the routing the datagram is either
delivered locally, or sent out one or more output interface. When it is
sent out, the routing algorithm must compute the next hop of its route.
The details are differ, depending on that the destination address is
multicast address or not.

When the datagram is decided to be sent up, it is processed as described
in the previous subsection (Receiving packets). If it is decided to be
sent out through some interface, it is actually sent to the :ned:`Arp`
module through the ``queueOut`` gate. An :msg:`IPv4RoutingDecision`
control info is attached to the outgoing packet, containing the outgoing
interface id, and the IP address of the next hop. The :ned:`Arp` module
resolve the IP address to a hardware address if needed, and forwards the
datagram to next hop.

Unicast/broadcast routing
^^^^^^^^^^^^^^^^^^^^^^^^^

When the higher layer generated the datagram, it will be processed in
these steps:

#. If the destination is the address of a local interface, then the
   datagram is locally delivered.

#. If the destination is the limited broadcast address, or a local
   broadcast address, then it will be broadcasted on one or more
   interface. If the higher layer specified am outgoing interface
   (:var:`interfaceId` in the control info), then it will be broadcasted
   on that interface only. Otherwise if the :par:`forceBroadcast` module
   parameter is ``true``, then it will broadcasted on all interfaces
   including the loopback interface. The default value of the
   :par:`forceBroadcast` is ``false``.

#. If the higher layer provided the routing decision (Manet routing),
   then the datagram will be sent through the specified interface to the
   specified next hop.

#. Otherwise IP finds the outgoing interface and the address of the next
   hop by consulting the routing table, and sends the datagram to the
   next hop. If no route found, then a ``Destination Unreachable``
   ICMP error is generated.

Incoming datagrams having unicast or broadcast destination addresses are
routed in the following steps:

#. Deliver datagram locally. If the destination address is a local
   address, the limited broadcast address (255.255.255.255), or a local
   broadcast address, then it will be sent to the transport layer.

#. Drop packets received from the network when IP forwarding is
   disabled.

#. Forward the datagram to the next hop. The next hop is determined by
   looking up the best route to the destination from the routing table.
   If the gateway is set in the route, then the datagram will be
   forwarded to the gateway, otherwise it is sent directly to the
   destination. If no route is found, then a ``Destination Unreachable``
   ICMP error is sent to the source of the datagram.

Multicast routing
^^^^^^^^^^^^^^^^^

Outgoing multicast datagrams are handled as follows:

If the higher layer set the :var:`multicastLoop` variable to
``true``, the IP will send up a copy of the datagram through the
loopback interface.

Determine the outgoing interface for the multicast datagram, and send
out the datagram through that interface. The outgoing interface is
determined by the following rules:

if the HL specified the outgoing interface in the control info, the it
will be used

otherwise use the interface of the route configured in the routing table
for the destination address

if no route found, then use the interface whose address matches the
source address of the datagram

if the HL did not specify the source address, then use the first
multicast capable interface

if no such interface found, then the datagram is unroutable and droppped

Incoming multicast datagrams are forwarded according to their source
address (Reverse Path Forwarding), i.e. datagrams are sent away from
their sources instead towards their destinations. The multicast routing
table maintains a spanning tree for each source network and multicast
group. The source network is the root of the tree, and there is a path
to each LAN that has members of the multicast group. Each node expects
the multicast datagram to arrive from their parent and forwards them
towards their children. Multicast forwarding loops are avoided by
dropping the datagrams not arrived on the parent interface.

More specifically, the routing routine for multicast datagrams performs
these steps:

#. Deliver a copy of the datagram locally. If the interface on which the
   datagram arrived belongs to the multicast group specified by the
   destination address, it is sent up to the transport layer.

#. Discard incoming packets that can not be delivered locally and can
   not be forwarded. A non-local packet can not be forwarded if
   multicast forwarding is disabled, the destination is a link local
   multicast address (224.0.0.x), or the TTL field reached 0.

#. Discard the packet if no multicast route found, or if it did not
   arrive on the parent interface of the route (to avoid multicast
   loops). If the parent is not set in the route, then the shortest path
   interface to the source is assumed.

#. Forward the multicast datagram. A copy of the datagram is sent on
   each child interface described by multicast routes (except the
   incoming interface). Interfaces may have a :var:`ttlThreshold`
   parameter, that limits the scope of the multicast: only datagrams
   with higher TTL are forwarded.

The IPv4RoutingTable Module
---------------------------

Interfaces are dynamically registered: at the start of the simulation,
every L2 module adds its own interface entry to the table.

The route table is read from a file; the file can also fill in or
overwrite interface settings. The route table can also be read and
modified during simulation, typically by routing protocol
implementations (e.g. OSPF).

Entries in the route table are represented by :cpp:`Ipv4Route` objects.
:cpp:`Ipv4Route` objects can be polymorphic: if a routing protocol needs
to store additional data, it can simply subclass from :cpp:`Ipv4Route`,
and add the derived object to the table. The :cpp:`Ipv4Route` object has
the following fields:

-  ``host`` is the IP address of the target of the route (can be a
   host or network). When an entry searched for a given destination
   address, the destination address is compared with this ``host``
   address using the ``netmask`` below, and the longest match wins.

-  ``netmask`` used when comparing ``host`` with the detination
   address. It is 0.0.0.0 for the default route, 255.255.255.255 for
   host routes (exact match), or the network or subnet mask for network
   routes.

-  ``gateway`` is the IP address of the gateway for indirect routes,
   or 0.0.0.0 for direct routes. Note that 0.0.0.0 can be used even if
   the destination is not directly connected to this node, but can be
   found using proxy ARP.

-  ``interface`` the outgoing interface to be used with this route.

-  ``type`` ``DIRECT`` or ``REMOTE``. For direct routes, the
   next hop address is the destination address, for remote routes it is
   the gateway address.

-  ``source`` ``MANUAL``, ``IFACENETMASK``, ``RIP``,
   ``OSPF``, ``BGP``, ``ZEBRA``, ``MANET``, or
   ``MANET2``. ``MANUAL`` means that the route was added by a
   routing file, or a network configurator. ``IFACENETMASK`` routes
   are added for each interface of the node. Other values means that the
   route is managed by the specific routing daemon.

-  ``metric`` the “cost” of the route. Currently not used when
   choosing the best route.

In multicast routers the routing table contains multicast routes too. A
multicast route is represented by an instance of the
:cpp:`Ipv4MulticastRoute` class. The :cpp:`Ipv4MulticastRoute` instance
stores the following fields:

-  :var:`origin` IP address of the network of the source of the datagram

-  :var:`originNetmask` netmask of the source network

-  :var:`group` the multicast group to be matched the destination of the
   datagram. If unspecified, then the route matches with

-  :var:`parent` interface towards the parent link in the multicast
   tree. Only those datagrams are forwarded that arrived on the parent
   interface.

-  :var:`children` the interfaces on which the multicast datagram to be
   forwarded. Each entry contains a flag indicating if this interface is
   a leaf in the multicast tree. The datagram is forwarded to leaf
   interfaces only if there are known members of the group in the
   attached LAN.

-  :var:`source` enumerated value identifying the creator of the entry.
   ``MANUAL`` for static routes, ``DVRMP`` for the DVMRP routers,
   ``PIM_SM`` for PIM SM routers.

-  :var:`metric` the “cost“ of the route.

When there are several multicast routes matching the source and
destination of the datagram, then the forwarding algorithm chooses the
one with the

#. the longest matching source

#. the more specific group

#. the smallest metric.

The ICMP Module
---------------

The :ned:`Icmp` module has two methods which can be used by other
modules to send ICMP error messages:

-  :fun:`sendErrorMessage(IPv4Datagram*, ICMPType, ICMPCode)`

   used by the network layer to report erronous IPv4 datagrams. The ICMP
   header fields are set to the given type and code, and the ICMP
   message will encapsulate the given datagram.

-  :fun:`sendErrorMessage(cPacket*, IPv4ControlInfo*, ICMPType, ICMPCode)`
   used by the transport layer components to report erronous packets.
   The transport packet will be encapsulated into an IP datagram before
   wrapping it into the ICMP message.

The :ned:`Icmp` module can be accessed from other modules of the node by
calling :fun:`ICMPAccess::get()`.

When an incoming ICMP error message is received, the :ned:`Icmp` module
sends it out on the ``errorOut`` gate unchanged. It is assumed that
an external module is connected to ``errOut`` that can process the
error packet. There is a simple module (:ned:`ErrorHandling`) that
simply logs the error and drops the message. Note that the :ned:`Ipv4`
module does not send REDIRECT, DESTINATION_UNREACHABLE, TIME_EXCEEDED
and PARAMETER_PROBLEM messages to the :ned:`Icmp` module, it will send
them to the transport layer module that sent the bogus packet
encapsulated in the ICMP message.

.. note::

   ICMP protocol encapsulates only the IP header + 8 byte following the IP header
   from the bogus IP packet. The ICMP packet length computed from this truncated
   packet, despite it encapsulates the whole IP message object.
   As a consequence, calling :fun:`decapsulate()` on the ICMP message
   will cause an "packet length became negative" error. To avoid this,
   use :fun:`getEncapsulatedMsg()` to access the IP packet that caused the ICMP
   error.

The :ned:`Icmp` module receives ping commands on the ``pingIn`` gate
from the application. The ping command can be any packet having an
:cpp:`Ipv4ControlInfo` control info. The packet will be encapsulated
with an :msg:`IcmpHeader` and handed over to the IP.

If :ned:`Icmp` receives an echo request from IP, the original message
object will be returned as the echo reply. Of course, before sending
back the object to IP, the source and destination addresses are swapped
and the message type changed to ICMP_ECHO_REPLY.

When an ICMP echo reply received, the application message decapsulated
from it and passed to the application through the ``pingOut`` gate.
The :cpp:`Ipv4ControlInfo` also copied from the :msg:`IcmpHeader` to
the application message.
