:orphan:

.. _dg:cha:tags

Communicating with Tags
=======================

Overview
--------

Modules often exchange information by sending packets along with supplementary
data, referred to as tags. A tag is usually a small data structure that focuses
on a single aspect of a protocol's parameterization. Tags can be attached to the
whole packet, known as packet tags, or to specific parts of the packet, known
as region tags. Tags are implemented as C++ classes that serve as data containers
and are usually generated by the OMNeT++ MSG compiler. The primary types of tags
are as follows:

- *Requests* carry information from higher layers to lower layers (e.g., :cpp:`MacAddressReq`).
- *Indications* carry information from lower layers to higher layers (e.g., :cpp:`InterfaceInd`).
- *Plain tags* contain meta-information (e.g., :cpp:`PacketProtocolTag`).
- *Base classes* must not be attached to packets (e.g., :cpp:`TagBase`).

For example, a request tag that specifies the source and destination MAC address
could be implemented in an MSG file as shown below:

.. literalinclude:: lib/Snippets.msg
   :language: msg
   :start-after: !TagDefinitionExeample
   :end-before: !End
   :name: Tag definition example

The following is a short description of several commonly used packet tags:

- :cpp:`PacketProtcolTag`: Specifies the protocol of the packet's contents.
- :cpp:`DispatchProtocolReq`: Specifies the receiver protocol module inside the network node.
- :cpp:`EncapsulationProcotolReq`: Specifies the requested protocol header encapsulation order.
- :cpp:`SocketReq`: Specifies the application socket.
- :cpp:`L4PortReq`: Specifies the source and destination ports.
- :cpp:`L3AddressReq`: Specifies source and destination network addresses.
- :cpp:`InterfaceReq`: Specifies the outgoing network interface.
- :cpp:`NextHopAddressReq`: Specifies the next-hop address for packet routing.
- :cpp:`VlanReq`: Specifies the virtual LAN identifier of IEEE 802.1Q.
- :cpp:`PcpReq`: Specifies the priority code point of IEEE 802.1Q.
- :cpp:`StreamReq`: Specifies the TSN stream identifier inside the network node.
- :cpp:`MacAddressReq`: Specifies source and destination MAC addresses.
- :cpp:`Ieee80211ModeReq`: Specifies the IEEE 802.11 PHY mode.
- :cpp:`Ieee80211ChannelReq`: Specifies the IEEE 802.11 channel.
- :cpp:`SignalPowerReq`: Specifies transmit signal power.

All request tags have their corresponding indication tags. For example, there
are indications such as :cpp:`SocketInd`, :cpp:`InterfaceInd`, and :cpp:`StreamInd`.
The requests are usually attached to outgoing packets, while the indications are
usually attached to incoming packets.

The following is a short description of several commonly used region tags:

- :cpp:`IdentityTag`: Uniquely identifies individual bits in the network over the lifetime of the whole simulation.
- :cpp:`CreationTimeTag`: Specifies the creation time of data regions for lifetime measurements.
- :cpp:`FlowTag`: Specifies the packet flows of data regions for various flow-specific measurements.
- :cpp:`PacketEventTag`: Carries information about queueing, processing, transmission, etc. events that happened to data regions.


Communicating Through Protocol Layers
-------------------------------------

Tags can pass through protocol modules, potentially reaching far beyond the module
that initially attached them, in both the downward and upward directions. Typically,
tags are removed at the point where they are processed, either by being transformed
into header fields within a packet or used for some protocol-specific decision-making.
Protocols have the freedom to disregard any tags based on their configuration and state.

Both packet tags and region tags usually remain unchanged for many operations
that protocol modules carry out with packets. For example, when packets are
enqueued/dequeued, encapsulated/decapsulated, cloned, buffered, or stored for later reuse,
the tags remain unchanged.

Specifying the Protocol of a Packet
----------------------------------

The most important packet tag is the :cpp:`PacketProtocolTag`. It specifies the
outermost protocol of the packet. This tag should always be present because the
packet protocol cannot be correctly determined just by looking at the raw data.
In contrast, the inner protocol headers in the packet can usually be recursively
identified by protocol fields such as the protocol ID field of the IPv4 header.
The :cpp:`PacketProtocolTag` is used, among other things:
- for dissecting the packet along the protocol headers,
- for printing the packet as a human-readable string to help interpret its contents.

Normally, a packet is transformed from one protocol to another in a single step,
so the packet protocol tag either specifies the protocol before the operation
or the protocol after the operation. For example, the :ned:`Udp` protocol module
encapsulates the outgoing packet using a :cpp:`UdpHeader`. The packet protocol
is set to an application-specific protocol before the UDP encapsulation, and it's
set to the UDP protocol after the encapsulation.

Sometimes, protocol implementations themselves are split up into several smaller
modules. For example, the modular Ethernet implementation uses a separate module
for the insertion of the Ethernet MAC header and the Ethernet FCS. In such a case,
the packet protocol tag can only specify the inner protocol that is being encapsulated
into an Ethernet MAC frame.

Dispatching Packets to Protocol Modules
--------------------------------------

Inside a network node, protocol modules interact with one another by sending
:cpp:`Packet` or :cpp:`Message` objects. INET provides great flexibility in terms
of how the protocol modules can be connected. Protocols can be connected directly
to each other or they can be connected through one or more :ned:`MessageDispatcher`
modules. This flexibility allows for the creation of simple as well as complex
network node architectures.

How to Connect Protocol Modules
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

Simple network nodes can be constructed using a linear protocol stack, where
protocol modules are directly connected to one another without using message dispatcher modules.

.. figure:: figures/SimpleHost.png
   :width: 160

   Simple network node structure in the IDE

More complex network nodes can be created by grouping protocols into layers and
connecting them through :ned:`MessageDispatcher` modules, which facilitate
many-to-one and many-to-many relationships among the protocols of the layers.

.. figure:: figures/ComplexHost.png
   :width: 240

   Complex network node structure in Qtenv

It's also possible to use message dispatcher modules hierarchically within
multiple levels of nested compound modules. Ultimately, one could even connect
all protocols to a single central message dispatcher module. However, please note
that only one instance of a given protocol module can be connected to a message dispatcher.

To support the packet dispatching mechanism, certain additional requirements
must be met in the C++ code:

- Protocols must be registered using the :fun:`registerProtocol` function.
- Packets must have the :cpp:`DispatchProtocolReq` tags attached.

Registering Protocols
~~~~~~~~~~~~~~~~~~~~~

Protocol modules must call the :fun:`registerProtocol` function from the :fun:`initialize` method to inform connected :ned:`MessageDispatcher`
modules of their presence. The following code fragment demonstrates this for the
IPv4 protocol implementation:

.. literalinclude:: lib/Snippets.cc
   :language: cpp
   :start-after: !ProtocolRegistrationExample
   :end-before: !End
   :name: Protocol registration example

Registering the protocols allows the dispatcher modules to learn which gates
the protocol modules are connected to. The same protocol is not allowed to be
registered in the same message dispatcher using different gates because that
would make the dispatching mechanism ambiguous.

Sending Packets with Dispatch Request
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

In order for the message dispatcher modules to correctly dispatch packets to
the intended recipient within the network node, packets and messages must have
the :cpp:`DispatchProtocolReq` tag attached. The following example shows how
a MAC protocol could send up a packet to the :ned:`Ipv4` protocol module without
actually knowing where that module is connected in the network node architecture:

.. literalinclude:: lib/Snippets.cc
   :language: cpp
   :start-after: !PacketDispatchingExample
   :end-before: !End
   :name: Packet dispatching example

The :cpp:`DispatchProtocolReq` tag specifies both the intended recipient protocol
and the requested service primitive. The service primitive, similarly to OSI
terminology, can be one of the following:

- :cpp:`SP_REQUEST` for service requests from layer N+1 to layer N
- :cpp:`SP_CONFIRM` for service confirmations from layer N to layer N+1
- :cpp:`SP_INDICATION` for protocol indications from layer N to layer N+1
- :cpp:`SP_RESPONSE` for protocol response from layer N+1 to layer N

Currently, INET modules only use the :cpp:`SP_REQUEST` and :cpp:`SP_INDICATION`
service primitives; the other two are only present for completeness. The request
service primitive is used when a higher layer protocol module (e.g., :ned:`Tcp`)
wants to deliver a packet to a lower layer protocol module (e.g., :ned:`Ipv4`).
Similarly, the :cpp:`SP_INDICATION` service primitive is used when a lower layer
protocol module (e.g., :ned:`Ethernet`) wants to deliver a packet to a higher layer
protocol module (e.g., :ned:`Ipv4`).

Determining the Next Protocol
-----------------------------

A protocol module has several options for determining which protocol to forward
a packet to. Some possibilities include:

- Hard-coding the next protocol in C++. For example, the UDP protocol is
  hard-coded in C++ in the :cpp:`UdpSocket` class, and similarly, other protocols
  are also hard-coded in other protocol-specific sockets.

- Specifying the next protocol using a module parameter. For instance, a network
  interface module can specify its expected protocol. The :ned:`Ipv4` module
  uses this information to dispatch a packet to the expected protocol of the
  selected route's network interface.

- Determining the next protocol based on module state. For example, the TSN
  stream encoder module forwards packets that match the TSN stream mapping to
  the 802.1 Q-TAG protocol for encapsulation.

- Determining the next protocol based on a packet header field. The :ned:`Ipv4`
  module, for example, uses the IP protocol ID header field from the 
  :cpp:`Ipv4Header` to look up the next protocol, as shown below:

  .. literalinclude:: lib/Snippets.cc
     :language: cpp
     :start-after: !NextProtocolExample
     :end-before: !End
     :name: Next protocol example

- Determining the next protocol based on packet metadata. For instance, the :ned:`Tcp` module
  uses the type of the destination address from the :cpp:`L3AddressReq` tag to determine
  whether the packet should be sent to the :ned:`Ipv4` or :ned:`Ipv6` module.

- Indirectly specifying the next protocol via a protocol encapsulation request.
  Other modules may have attached an :cpp:`EncapsulationProtocolReq` to the
  packet in an earlier stage of the packet processing.

Controlling the Packet Encapsulation Order
------------------------------------------

A packet typically contains multiple protocol-specific headers, such as TCP, IP,
Ethernet, and sometimes additional optional headers like 802.1Q, 802.1R, 802.1AE,
and others. The order of the packet headers is determined by the order in which
the packet reaches the relevant protocol modules for encapsulation.

The encapsulation process may need to be different for each packet. For example,
an application may need to send a packet to a specific VLAN. In this case, the
application should attach a :cpp:`VlanReq` tag to the packet with the desired
VLAN ID. However, it cannot directly send the packet to the relevant 802.1Q
protocol module because the packet may need to be delivered to the UDP protocol
first. To achieve the desired protocol encapsulation order, the application should
also attach an :cpp:`EncapsulationProtocolReq` tag that specifies that the packet
should ultimately be delivered to the 802.1Q protocol for encapsulation. The
underlying protocol modules will use this information to determine when the
802.1Q encapsulation should take place.

The :cpp:`EncapsulationProtocolReq` generally outlines the sequence of protocol
modules that a packet should be delivered to for further encapsulation. Additional
tags attached to the packet are used as additional parameters for the requested
processing steps. The attached encapsulation request may be changed several times
during packet processing; new protocols may be added, already added protocols
may be removed, etc.

For example, the IP protocol determines the outgoing interface using the routing
table and the destination address. The selected network interface specifies the
expected protocol that the packet should have in order for the interface module
to operate properly. The specified protocol is appended to the end of the requested
encapsulation protocols of the packet because it should be the last encapsulation
before the packet reaches the network interface. For example, if the IP module
selects an Ethernet network interface, then it appends the Ethernet MAC protocol
to the :cpp:`EncapsulationProtocolReq`. As a result, the packet is ultimately encapsulated
into an :cpp:`EthernetMacHeader` before reaching the network interface module.

Transforming Inbound Packets to Outbound
----------------------------------------

As part of the forwarding process of Ethernet switches, an inbound packet is
transformed into an outbound packet. By default, this process is carried out by
the :ned:`PacketDirectionReverser` module. The transformation is more like a
policy and can be replaced by the user with other modules. The default module
doesn't change the packet contents, except for removing the already popped front
and back parts. However, it changes the attached packet tags significantly.

The inbound packet usually contains a few tags such as :cpp:`PacketProtocolTag`
and :cpp:`DirectionTag`, and it also contains several indications such as the
:cpp:`InterfaceInd`, :cpp:`MacAddressInd`, :cpp:`VlandInd`, :cpp:`PcpInd`,
:cpp:`EncapsulationProtocolInd`, etc. During the transformation, only the
:cpp:`PacketProtocolTag` is kept, and all attached indications are removed.
Additionally, a set of requests is attached to the packet so that the packet will
be encapsulated in the same protocol headers and sent out on the same interface as it came in.

Of course, this is just the start of the processing of the outbound packet.
During the several steps that follow, any of the attached requests can be
replaced with new ones, potentially resulting in the packet being handled in a completely different way.